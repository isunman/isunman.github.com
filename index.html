<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Sunman，太阳侠" />





  <link rel="alternate" href="/atom.xml" title="太阳侠" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="love IT, love Movie, love Love">
<meta property="og:type" content="website">
<meta property="og:title" content="太阳侠">
<meta property="og:url" content="http://isunman.com/index.html">
<meta property="og:site_name" content="太阳侠">
<meta property="og:description" content="love IT, love Movie, love Love">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="太阳侠">
<meta name="twitter:description" content="love IT, love Movie, love Love">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>

  <title> 太阳侠 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?edc09d74f003ef7b14a37137efc44fd4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">太阳侠</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">我是一颗恒星</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2025/03/08/A-few-thoughts-on-AI-and-large-models/" itemprop="url">
                  关于AI与大模型的几点想法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2025-03-08T23:23:00+08:00" content="2025-03-08">
              2025-03-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/大模型/" itemprop="url" rel="index">
                    <span itemprop="name">大模型</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、模型不是产品"><a href="#一、模型不是产品" class="headerlink" title="一、模型不是产品"></a>一、模型不是产品</h3><p>AI大模型会折叠掉大量按照过去思路设计的产品，但也会催生一个全新的产品簇。从对旧世界产品的破坏来讲，模型即产品；从创建新产品世界来讲模型不是产品。</p>
<h5 id="1、人的角色和价值"><a href="#1、人的角色和价值" class="headerlink" title="1、人的角色和价值"></a>1、人的角色和价值</h5><p>知识的螺旋-组织是知识的载体，知识是组织的本质<br><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2025%2F0308%2Feae363b4j00sssikj006pd200u000h8g00fe008u.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p>
<p>但在新模式下，AI驱动的组织既承载知识也创造知识。</p>
<p>AI不会创造所有知识，真正的新知识创建还有人类的角色在。</p>
<p>人与智能组织的协作边界是需要复杂定义的，并且每个公司的知识系统不一样，偏好不一样，模型自身不能包含所有公司的偏好和特征。</p>
<h5 id="2、数字与非数字的边界"><a href="#2、数字与非数字的边界" class="headerlink" title="2、数字与非数字的边界"></a>2、数字与非数字的边界</h5><p>人和AI的权重是动态的</p>
<p>在知识创造过程中，人可以调度这四个维度上信息进行知识创造，AI也可以。因为这里面很多东西是私有的，所以私有知识应运而生。</p>
<p>边界之外可以归于模型，这是归一化的，边界以里归于自身，这是差异化的。也就是说如果企业不创造差异化的知识，那基本没有存在价值。</p>
<p><strong>那其实就是模型的归模型（通用知识和通用智能），应用的归应用（任务导向的多角色联动，权限，物理世界的接入，人机协同边界的处理等）。</strong></p>
<h3 id="二、模型的产品化"><a href="#二、模型的产品化" class="headerlink" title="二、模型的产品化"></a>二、模型的产品化</h3><p>“模型作为产品”的两个典型例子：OpenAI 的 Deep Research 和 Claude Sonnet 3.7。　</p>
<p>Anthropic 一直在更清晰地阐述他们的愿景。他们提出了一个有争议但在我看来正确的 Agent 模型定义。　</p>
<p>类似于 Deep Search，Agent 必须在内部执行目标任务：它们”动态指导自己的过程和工具使用，控制完成任务的方式”。</p>
<p>目前大多数 Agent 初创公司构建的不是真正的 Agent，而是工作流，即”通过预定义的代码路径编排 LLM 和工具的系统”。工作流在某些垂直领域仍可能创造价值。</p>
<p>针对做C端产品来说，用户并不关心是Agent还是App，他们只关心问题是否被解决。技术路线的选择应该基于用户体验而非技术理想，<strong>最好的产品是让用户感受不到技术的存在</strong>。用户只需要提供需求场景和订单即可。技术进步的目标是创造实际价值，无论是Agent还是App，都需要解决真实问题。</p>
<p>我们的产品本来就在解决我们想要解决的问题，只是在没有AI大模型的支持时，需要找其他的方案；但是既然有了AI大模型的加持，我们的解决方案可以更酷更靓更高效更有趣更好玩。</p>
<p>同时，除了产品本身好玩以外，我们开发产品的工具与工作流程也会因为AI大模型的加持而彻底改变。不仅仅是提高效率，更可以做之前做不到的事，而且是以更小的成本。在这里又一次体现了“投入产出比”的计算意识的重要性。</p>
<p>这一切的关键，是我自己首先立即把大模型的能力给用起来，用到开发产品，用到产品本身。能用多很就用多很，大模型的能力像无底洞一样，这才用到哪。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>应无所住，而生其心。<br>真正的创造需要一颗鲜活的心。</strong></p>
<p>来源参考：<a href="https://mp.weixin.qq.com/s/5JzhJIUY3vpz4RGyobI7Ag" title="大模型的未来，是 Agent 还是 App？" target="_blank" rel="external">https://mp.weixin.qq.com/s/5JzhJIUY3vpz4RGyobI7Ag</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2023/08/21/comprehensive-analysis-of-PHP-FPM+Nginx-communication-principle/" itemprop="url">
                  全面剖析 PHP-FPM+Nginx 通信原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2023-08-21T14:50:00+08:00" content="2023-08-21">
              2023-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web构建/" itemprop="url" rel="index">
                    <span itemprop="name">Web构建</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>用了这么久了PHP+Nginx了，你了解他们之间的通信原理吗？这一次做一回真正的PHPer（在上一篇文章里边已经全面介绍了CGI、FastCGI、PHP-FPM，所以本文对于这些概念不再介绍的那么详细）</p>
<h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>PHP-FPM的全称是PHP FastCGI Process Manager，PHP-FPM是FastCGI的实现，并提供了进程管理的功能。FastCGI进程包含master进程和worker进程两种进程。master进程只有一个，负责监听端口，接收Nginx的请求，而worker进程则一般有多个(可配置)，每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。这里介绍一下什么是正向代理和反向代理，这个对于我们理解Nginx很重要</p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>我们那访问国外的网站为例，比如访问Google、Facebook。我们需要借助vpn才能访问，我们借助vpn访问国外的网站，其实就是个正向代理的过程，上图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-264693523af2543b568ed9aa7c7d97ec_720w.webp" alt=""></p>
<p>vpn对于用户来说，是可以感知到的（因为用户需要配置连接），vpn对于google服务器来说，是不可感知的(google服务器只知道有http请求过来)。所以，对于用户来说可以感知到，而对于服务器来说感知不到的服务器，就是正向代理服务器（vpn）</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>拿Nginx作为反向代理服务器实现负载均衡来举例，假设此时我们访问百度，看图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a9736998fd30679e11150296ada745d7_720w.webp" alt=""></p>
<p>当用户访问百度时，所有的请求会到达一个反向代理服务器，这个反向代理服务器会将请求分发给后边的某一台服务器去处理。此时，这个代理服务器其实对用户来说是不可感知的，用户感知到的是百度的服务器给自己返回了结果，并不知道代理服务器的存在。也就是说，对于用户来说不可感知，对于服务器来说是可以感知的，就叫反向代理服务器（Nginx）</p>
<h2 id="PHP-FPM-Nginx通信"><a href="#PHP-FPM-Nginx通信" class="headerlink" title="PHP-FPM+Nginx通信"></a>PHP-FPM+Nginx通信</h2><p>FastCGI致力于减少Web服务器与CGI程序之间互动的开销，从而使服务器可以同时处理更多的Web请求。与CGI这种为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。<strong>这些进程由FastCGI进程管理器管理，而不是web服务器</strong>。</p>
<p>通过图来理解PHP-FPM和Nginx的通信</p>
<p><img src="https://pic1.zhimg.com/80/v2-5b4221240c64823f21975422586e91dc_720w.webp" alt=""></p>
<p>（1）当Nginx收到http请求（动态请求），它会初始化FastCGI环境。（如果是Apache服务器，则初始化modefastcgi模块、如果是Nginx服务器则初始化ngxhttp_fastcgi_module）</p>
<p>（2）我们在配置nginx解析php请求时，一般会有这样一行配置：</p>
<pre><code>fastcgi_pass 127.0.0.1:9000;
</code></pre><p>或者长这样：<br>    fastcgi_pass unix:/tmp/php-cgi.sock;</p>
<p>它其实是Nginx和PHP-FPM一个通信载体（或者说通信方式），目的是为了让Nginx知道，收到动态请求之后该往哪儿发。（关于这两种配置的区别，后边会专门介绍）</p>
<p>（3）Nginx将请求采用socket的方式转给FastCGI主进程</p>
<p>（4）FastCGI主进程选择一个空闲的worker进程连接，然后Nginx将CGI环境变量和标准输入发送该worker进程（php-cgi）</p>
<p>（5）worker进程完成处理后将标准输出和错误信息从同一socket连接返回给Nginx</p>
<p>（6）worker进程关闭连接，等待下一个连接</p>
<h2 id="不从配置的角度，再描述一下PHP和Nginx的通信"><a href="#不从配置的角度，再描述一下PHP和Nginx的通信" class="headerlink" title="不从配置的角度，再描述一下PHP和Nginx的通信"></a>不从配置的角度，再描述一下PHP和Nginx的通信</h2><p>我们知道Nginx也是有master和worker进程的，worker进程直接处理每一个网络请求<br>其实在Nginx+PHP的架构里边，php可以看做是一个cgi程序的角色，因此出现了php-fpm进程管理器来处理这些php请求。php-fpm和nginx一样，也会监听端口（通过nginx.conf里的配置我们知道，nginx默认监听8080端口，php-fpm默认监听9000端口），并且有master和worker进程，worker负责处理每一个php请求<br>关于fastcgi：fastcgi是一个协议。市面上有多种实现了fastcgi协议的进程管理器，php-fpm就是其中的一种。php-fpm作为一种fastcgi进程管理服务，会监听端口，一般默认监听9000端口，并且是监听本机，也就是只接收来自本机的端口请求<br>关于fastcgi的配置文件，目前fastcgi的配置文件一般放在nginx.conf同级目录下，配置文件形式，一般有两种：</p>
<pre><code>fastcgi.conf和 fastcgi_params。
不同的nginx版本会有不同的配置文件，这两个配置文件有一个非常重要的区别：
fastcgi_parames文件中缺少下列配置：
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
</code></pre><p>我们可以打开fastcgi_params文件加上上述行，也可以在要使用配置的地方动态添加。使得该配置生效</p>
<p>当需要处理php请求时，nginx的worker进程会将请求移交给php-fpm的worker进程进行处理，也就是最开头所说的nginx调用了php，其实严格得讲是nginx间接调用php（反向代理的方式）<br>我本机配置了能正常解析php程序的nginx配置，介绍一下每一行配置的含义</p>
<pre><code>server{
listen 8080;
index index.php
root /work/html/;
location ~ [^/]\.php(/|$)
{
root /work/html/;
fastcgi_pass 127.0.0.1:9000;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
include fastcgi_params;
}
access_log /work/html/logs/test.log;
}
</code></pre><p>第一个大括号 server{ }：代表一个独立的server<br>listen 8080：代表该server监听8080端口<br>location ~ [^/].php(/|$){ }：代表一个能匹配对应uri的location，用于匹配一类uri，并对所匹配的uri请求做自定义的逻辑、配置。这里的location，匹配了所有带.php的uri请求，例如：<a href="http://192.168.244.128:8011/test.php/asdasdhttp://192.168.244.128:8011/index.php等" target="_blank" rel="external">http://192.168.244.128:8011/test.php/asdasdhttp://192.168.244.128:8011/index.php等</a><br>root /work/html/：请求资源根目录，告诉匹配到该location下的uri到/work/html/文件夹下去寻找同名资源<br>fastcgi_pass 127.0.0.1:9000：这行代码的意思是，将进入到该location内的uri请求看做是cgi程序，并将请求发送到9000端口，交由php-fpm处理(php-fpm配置中会看见它监听了此端口)<br>fastcgiparam SCRIPTFILENAME</p>
<p>fastcgiscriptname; ：这行配置意思是：动态添加了一行fastcgi配置，配置内容为SCRIPTFILENAME，告知管理进程，cgi脚本名称。由于我的nginx中只有fastcgiparams文件，没有fastcgi.conf文件，所以要使php-fpm知道SCRIPT_FILENAME的具体值，就必须要动态的添加这行配置</p>
<p>include fastcgi_params; 引入fastcgi配置文件</p>
<h3 id="fastcgi-pass"><a href="#fastcgi-pass" class="headerlink" title="fastcgi_pass"></a>fastcgi_pass</h3><p>Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP Socket,一种是Unix Socket.</p>
<p><strong>Tcp Socket方式是IP加端口,可以跨服务器.而UNIX Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景，用哪种取决于你的PHP-FPM配置</strong></p>
<p><strong>Tcp Socket方式：</strong></p>
<p>nginx.conf中配置：fastcgi_pass 127.0.0.1:9000;</p>
<p>php-fpm.conf中配置：listen=127.0.0.1:9000;</p>
<p><strong>Unix Domain Socket方式:</strong></p>
<p>nginx.conf中配置：fastcgi_pass unix:/tmp/php-fpm.sock;</p>
<p>php-fpm中配置：listen = /tmp/php-fpm.sock；</p>
<p>(php-fpm.sock是一个文件,由php-fpm生成)<br><strong><br>举例：</strong></p>
<p>两种通信配置方式，Nginx和PHP-FPM的通信过程如下：</p>
<p><strong>Tcp Socket：</strong></p>
<pre><code>Nginx &lt;=socket &lt;=TCP/IP &lt;=socket &lt;=PHP-FPM
</code></pre><p>(上边画Nginx和PHP-FPM通信的图时就是这种方式，这种情况是Nginx和PHP-FPM在同一台机器上)</p>
<p>看一下Nginx和PHP-FPM不在同一台机器上的情况：</p>
<pre><code>Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; 物理层 &lt;=&gt; 路由器 &lt;=&gt; 物理层 &lt;=&gt; 
TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM
</code></pre><p><strong>Unix Socket：</strong></p>
<pre><code>Nginx &lt;=&gt; socket &lt;=&gt; PHP-FPM
</code></pre><p><strong>include fastcgi_params;</strong><br>在nginx中有很多的fasgcgi*的配置，更多的配置可以在nginx.conf的同级目录中看到，在fastcgi.conf和fastcgiparams中，这两个的区别，上边有说明。看一下里边的内容：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e8044d378df04f7e255662c51242885_720w.webp" alt=""></p>
<p>这里边的内容都会被传递给PHP-FPM所管理的fastcgi进程。为什么会传递这些呢？相信大家都用过$SERVER这个全局变量，这里边的值就是从此配置中拿到的。我们可以在fastcgiparams中看到REMOTEADDR，就是客户端地址，PHP之所以能拿到客户端信息，就是因为Nginx的配置中的fastcgiparams。更多ngxhttpfastcgimodule模块的内容，可以看官方文档：<a href="http://nginx.org/en/docs/http/ngxhttp_fastcgi_module.html" target="_blank" rel="external">http://nginx.org/en/docs/http/ngxhttp_fastcgi_module.html</a></p>
<h2 id="php-fpm-conf配置"><a href="#php-fpm-conf配置" class="headerlink" title="php-fpm.conf配置"></a>php-fpm.conf配置</h2><p>熟悉php-fpm的配置，能帮助我们优化服务器性能</p>
<pre><code>emergency_restart_threshold = 60
emergency_restart_interval = 60s
</code></pre><p>表示在emergencyrestartinterval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergencyrestartthreshold个，php-fpm就会优雅重启。这两个选项一般保持默认值</p>
<pre><code>process_control_timeout = 0
</code></pre><p>设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</p>
<pre><code>listen = 127.0.0.1:9000
</code></pre><p>fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.</p>
<pre><code>request_slowlog_timeout = 10s
#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 
设置为 ’0′ 表示 ‘Off’
slowlog = log/$pool.log.slow
慢请求的记录日志,配合request_slowlog_timeout使用
</code></pre><p>下边几个配置参数比较重要：</p>
<pre><code>pm
pm指的是process manager，指定进程管理器如何控制子进程的数量，它为必填项，支持3个值
(1)static: 使用固定的子进程数量，由pm.max_children指定(可以同时存活的子进程的最大数量)
(2)dynamic：基于下面的参数动态的调整子进程的数量，至少有一个子进程(会使用下边几个配置)
pm.start_servers: 启动时创建的子进程数量，默认值为min_spare_servers + max_spare_servers -
 min_spare_servers) / 2
pm.min_spare_servers: 空闲状态的子进程的最小数量，如果不足，新的子进程会被自动创建
pm.max_spare_servers: 空闲状态的子进程的最大数量，如果超过，一些子进程会被杀死
(3)ondemand: 启动时不会创建子进程，当新的请求到达时才创建，有下边两个配置
pm.max_children
pm.process_idle_timeout 子进程的空闲超时时间，如果超时时间到没有新的请求可以服务，则会被
杀死
区别：
如果pm设置为 static，那么其实只有pm.max_children这个参数生效。系统会开启设置数量的
php-fpm进程
如果pm设置为 dynamic，那么pm.max_children参数失效，后面3个参数生效
系统会在php-fpm运行开始 的时候启动pm.start_servers个php-fpm进程，
然后根据系统的需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数
还有一个比较重要的配置：
pm.max_requests
每一个子进程的最大请求服务数量，如果超过了这个值，该子进程会被自动重启。在解决第三方库的
内存泄漏问题时，这个参数会很有用。默认值为0，指子进程可以持续不断的服务请求
</code></pre><h2 id="PHP-FPM进程池"><a href="#PHP-FPM进程池" class="headerlink" title="PHP-FPM进程池"></a>PHP-FPM进程池</h2><p>php-fpm.conf中默认配置了一个进程池，我们可以打开我们的php-fpm.conf看一下，下边是我的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-7365bfe451b0102092f528ea338dc5b6_720w.webp" alt=""></p>
<p>现在我们执行一下:ps -aux|grep php-fpm</p>
<p><img src="https://pic1.zhimg.com/80/v2-e62c2b5b0a6bef72d702cdc81fb82174_720w.webp" alt=""></p>
<p>会看见有一个master，10个worker进程，和我们配置的一样（www为进程池名）</p>
<p>想配置多个，这样做即可：</p>
<p><img src="https://pic2.zhimg.com/80/v2-56011c2443b60d0280be15ebd9df9ff9_720w.webp" alt=""></p>
<p>在nginx中fastcgi_pass这个地方配置使用哪个进程池即可。</p>
<p>（完）</p>
<p>原文参考：<a href="https://zhuanlan.zhihu.com/p/339250896" target="_blank" rel="external">知乎文章</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2023/05/16/network-digital-identity-authentication/" itemprop="url">
                  网络数字身份认证术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2023-05-16T20:15:00+08:00" content="2023-05-16">
              2023-05-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web构建/" itemprop="url" rel="index">
                    <span itemprop="name">Web构建</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章是<a href="https://coolshell.cn/articles/19395.html" target="_blank" rel="external">《HTTP API 认证授权术》</a>的姊妹篇，在那篇文章中，主要介绍了 HTTP API 认证和授权技术中用到的 HTTP Basic, Digest Access, HMAC, OAuth, JWT 等各种方式，主要是 API 上用到的一些技术，这篇文章主要想说的是另一个话题——身份认证。也就是说，怎么确认这个数据就是这个人发出来的？</p>
<h2 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h2><p>要解决这个问题，我们先来看一个最简单的解——使用密码，通常来说，在网络上要证明一个人的身份的话，都需要这个人的一些私密而唯一的东西。比如，像密码这样的东西，很多地方，只要你提供了你的用户名+密码，就可以确定这个人是你（注明：关于密码管理，强密码设定，密码泄漏，密码破解以及密码哄骗不在这篇文章的话题中），也就是说，这个密码是非常私密的事，我们可以假设，这个事全世界只能有当事人一个人知道，所以，当事人得供正确的密码，我们就可以认证这个人了。</p>
<p>为了加强密码的安全程度，一般会使用 2FA（Two-factor authentication）或 MFA（Multi-factor authentication），双因认证或多因认证，这需要用户提供一个唯一的可信设备，比如用户的手机，然后通过验证手机短信，或是像 Google Authenticator  这样的动态口令来完成。这样的安全级别已经算是比较高了。如果能够再加上经常性的变更密码，那么安全级别就更好了。</p>
<p>另外，一些公司还使用了生物密码来进行用户的身份验证，比如人脸识别。但是，我个人觉得人脸识别或是生物识别是比较糟糕的方式，因为：</p>
<ul>
<li>目前能被验证的生物信息（如人脸和指纹）太容易被别人获得和伪造了。</li>
<li>这样东西不能被变更和吊销，密码可以被吊销和重置，人脸则不能。</li>
</ul>
<h2 id="密钥对和证书"><a href="#密钥对和证书" class="headerlink" title="密钥对和证书"></a>密钥对和证书</h2><p>密码可以解决身证认证的问题有很多问题，最重要的一个问题就是，你要把你的密码提供给对方，对方才能验证你的身份。你不可能把你的密码提供给全世界的人吧，这样的话，全世界的人都有你的密码了，那么任何人都能变成你了。所以，用户密码这个事只能存在于权威机构和普通用户之间，不能存在于普遍应用中。所以，这里需要使用更好的解决方案。</p>
<p>使用 ECC（Elliptic-Curve Cryptography）椭圆曲线密码术，可以通过一个“密钥对”进行非对称加密。这种技术，在对信息进行加密和解密时，使用两个不同的密钥，其中一个用来做加密，另一个做解密。这样一来，我们就可以把其中一个密钥公布出去，称之为公钥，另一个密钥私密地保管好，称之为私钥。</p>
<p>比如，我用我的私钥加密信息，然后，我把这个私钥所配对的公钥发布给所有人，大家都用公钥解密信息，不用我的公钥你解密不了这个信息。这样一来，就可以保证这个信息是我发出来的，不但保证了信息安全，还完成了身份认证。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2022/01/key.pair_-768x293.png" alt=""></p>
<p>这样的现实案例一般用于网站，也就是用户得要知道我访问的这个网站是真实的，不是别人做的。因为 DNS 很容易被 hack，你连上一个不可信的网络，这个网络里的 DNS 把这个网站的 IP 地址解析成什么 就是什么了。但是有了这个加密的机制后，网站把自己的信息加密后连同公钥给到访问者，访问解密后就知道是不是这个网站了。</p>
<p>但是，这里还是会有一个很严重的问题，那就是中间人攻击。如下图所示：</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2022/01/key.pair_-768x293.png" alt=""></p>
<p>中间人 Chad 把自己伪装成 Bob 向 Alice 要信息，然后，再伪装成 Alice 对 Bob 说，这就是 Alice 的公钥，于是 Bob 也无法验证是不是 Alice 的公钥，因为公钥里就是一堆乱七八糟的数据，我们完全不能分辨哪个公钥属于 Alice 的。试想，如果我们收到声称属于银行的密钥。我们怎么知道它确实属于你的银行？</p>
<p>这里的答案就是<strong>使用数字证书</strong>。证书跟我们的身份证非常类似，其需要一个可信机构来颁发和验证的。这个证书机构 CA（Certificate Authority）是一个是大家都相信的权威机构，他用他的人品保证（当然一般会被严格管理和审计），CA 机构同样使用这样的非对称加密的技术来完成颁发和验证的事。下图展示了这一过程。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2022/01/certificate-768x399.png" alt=""></p>
<p>说明一下上面这个图：</p>
<ol>
<li>为了解决公钥认证的问题的，我们需要一个权威的CA 机构。</li>
<li>Alice 把自己的信息（姓名、组织，地址，电邮，网址等）和自己的公钥打包成一个 CSR 的文件，发给 CA 机构，</li>
<li>CA 机构会来找 Alice 做物理世界的认证，如果通过后，就会用自己的机构私钥，把CSR 变成一个签名证书。</li>
<li>Bob 同学拿到 Alice 的证书，用 CA 机构的公钥解密后，得到 Alice 的公钥</li>
<li>后面就可以签证 信息是否来自 Alice 了。</li>
</ol>
<p>是的，这个过程就是在“套娃”，这种证书机构还可以给下级的证书机构发证，于是就会一层套一层地，形成一个证书链，顶层的叫根证书，你得绝对信任之。对于验证证书真实性的客户端，它需要能够验证链中所有 CA 的签名，这意味着客户端需要访问链中所有 CA 的证书。</p>
<h2 id="证书生成过程演示"><a href="#证书生成过程演示" class="headerlink" title="证书生成过程演示"></a>证书生成过程演示</h2><p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 openssl命令来演示这个过程。</p>
<p>1）生成 CA 的证书（公钥） ca.crt 和私钥 ca.key</p>
<pre><code>openssl req -newkey rsa:2048 \
-new -nodes -x509 \
-days 365 \
-out ca.crt \
-keyout ca.key \
-subj &quot;/C=SO/ST=Earth/L=Mountain/O=CoolShell/OU=HQ/CN=localhost&quot;
</code></pre><p>2)  生成 alice 的私钥</p>
<pre><code>openssl genrsa -out alice.key 2048
</code></pre><p>3）生成 Alice 的 CSR – Certificate Signing Request</p>
<pre><code>openssl req -new -key alice.key 365 -out alice.csr \
-subj &quot;/C=CN/ST=Beijing/L=Haidian/O=CoolShell/OU=Test/CN=localhost.alice&quot;
</code></pre><p>4）使用 CA 给 Alice 签名证书</p>
<pre><code>openssl x509  -req -in alice.csr \
-extfile &lt;(printf &quot;subjectAltName=DNS:localhost.alice&quot;) \ 
-CA ca.crt -CAkey ca.key  \
-days 365 -sha256 -CAcreateserial \
-out alice.crt
</code></pre><p>##双向认证 mTLS<br>上面，我们说的基本上都是单向认证，大量的场景都是确保用户方访问的是真正的服务方，如：银行，电商网站，等。这样可以保证用户不会被钓鱼网站或是中间人攻击。但是，很多时候，我们也是需要双向认证的。下面是一个典型的场景——微信支付和商户间交互</p>
<ul>
<li>用户到商家那边买东西，商家要求用户进行支付。</li>
<li>用户选择了微信支付，于是，界面从商户侧切到了微信侧</li>
<li>微信那边支付完成后，商户这边收到微信那边支付完成的通知，于是开始发货。</li>
</ul>
<p>这个过程中有件事非常重要——就是微信通知商户支付完成的时候。</p>
<ul>
<li>微信得确保通知到的就是用户所支付商户，而不是别个。</li>
<li>商户也得要能确认，来通知我的就是微信，不是别人。</li>
</ul>
<p>一般来说，微信会给商户一个 AppID和一个 AppSerct，用这个来确保是我认证过的商户来调用我，然后，需要商户在自己的系统里填一个回调的 URL，并通过平台设置的 key来做 MD5/HMAC的签名来确保是官方的回调。这都是在《HTTP API 认证授权术》中提到过的技术，是相对传统的技术。</p>
<p>如今，<strong>mTLS</strong>是确保云原生应用程序中服务之间的通信安全的首选协议。 也就是双向认证。</p>
<p>传统的 TLS 认证过程是：</p>
<ol>
<li>客户端连接到服务器</li>
<li>服务器提供其 TLS 证书</li>
<li>客户端验证服务器的证书</li>
<li>客户端和服务器通过加密的 TLS 连接交换信息</li>
</ol>
<p>在 mTLS 中，客户端和服务器都有一个证书，双方都使用他们的公钥/私钥对进行身份验证。与常规 TLS 相比，mTLS 中有额外的步骤来验证双方（以粗体显示的额外步骤）：</p>
<ol>
<li>客户端连接到服务器</li>
<li>服务器提供其 TLS 证书</li>
<li>客户端验证服务器的证书</li>
<li><strong>客户端出示其 TLS 证书</strong></li>
<li><strong>服务器验证客户端的证书</strong></li>
<li><strong>服务器授予访问权限</strong></li>
<li>客户端和服务器通过加密的 TLS 连接交换信息</li>
</ol>
<p>mTLS 需要“根”TLS 证书；这我们自己来完成证书颁发机构的职责。授权客户端和服务器使用的证书必须与此根证书相对应。根证书是自签名的，这意味着我们需要自己创建它。（注：此方法不适用于公共 Internet 上的单向 TLS，因为外部证书颁发机构必须颁发这些证书）</p>
<p>那么，为什么整个互联网上都用了 TLS 了，为什么 不升级一下使用 mTLS？这里有两方面的原因：</p>
<ul>
<li>公共互联网上要解决的问题是：A) 确保用户访问到的是正确的网站，而不是钓鱼网站。B）网站传输的内容是安全和私密且不会被篡改的。</li>
<li>将 TLS 证书分发到所有最终用户设备将非常困难。生成、管理和验证为此所需的数十亿个证书几乎是不可能的任务。</li>
</ul>
<p>在较小的范围内，mTLS 对于单个组织非常有用且非常实用，尤其是当这些组织采用零信任方法来确保网络安全时。由于默认情况下零信任方法不信任任何用户、设备或请求，因此组织必须能够在每次尝试访问网络中的任何点时对每个用户、设备和请求进行身份验证。mTLS 通过对用户进行身份验证和设备验证来帮助实现这一目标。</p>
<p>关于 mTLS，这里有一个我用 Golang 写的示例 – <a href="https://github.com/haoel/mTLS，大家可以参考一下。" target="_blank" rel="external">https://github.com/haoel/mTLS，大家可以参考一下。</a></p>
<p>P.S. 本文图版中的卡司来自安全圈的标准 Cast，参看 Alice and Bob。</p>
<p>（全文完）</p>
<p>原文链接：<a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="external">《网络数字身份认证术》</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2023/05/16/http-api-authentication-and-authorization/" itemprop="url">
                  HTTP API 认证授权术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2023-05-16T20:03:00+08:00" content="2023-05-16">
              2023-05-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web构建/" itemprop="url" rel="index">
                    <span itemprop="name">Web构建</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。</p>
<p>但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。注意，这是一篇长文！</p>
<p>本篇文章会覆盖如下技术：</p>
<ul>
<li>HTTP Basic</li>
<li>Digest Access</li>
<li>App Secret Key + HMAC</li>
<li>JWT – JSON Web Tokens</li>
<li>OAuth 1.0 – 3 legged &amp; 2 legged</li>
<li>OAuth 2.0 – Authentication Code &amp; Client Credential</li>
</ul>
<h2 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h2><p>HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication</p>
<p>其技术原理如下：</p>
<blockquote>
<p>1、把 username和 password 做成  username:password 的样子（用冒号分隔）</p>
<p>2、进行Base64编码。Base64(“username:password”) 得到一个字符串（如：把 haoel:coolshell 进行base64 后可以得到 aGFvZW86Y29vbHNoZWxsCg ）</p>
<p>3、把 aGFvZW86Y29vbHNoZWxsCg放到HTTP头中 Authorization 字段中，形成 Authorization: Basic aGFvZW86Y29vbHNoZWxsCg，然后发送到服务端。</p>
<p>4、服务端如果没有在头里看到认证字段，则返回401错，以及一个个WWW-Authenticate: Basic Realm=’HelloWorld’ 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。</p>
</blockquote>
<p>我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 JIRA Cloud 的API认证支持HTTP Basic 这样的方式。</p>
<p>但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。</p>
<h2 id="Digest-Access"><a href="#Digest-Access" class="headerlink" title="Digest Access"></a>Digest Access</h2><p>中文称“HTTP 摘要认证”，最初被定义在了 RFC 2069 文档中（后来被 RFC 2617 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。</p>
<p>其基本思路是，请求方把用户名口令和域做一个MD5 –  MD5(username:realm:password) 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 nonce 另一个是 qop</p>
<ul>
<li>首先，调用方发起一个普通的HTTP请求。比如：GET /coolshell/admin/ HTTP/1.1</li>
<li>服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 WWW-Authenticate 包含如下信息：</li>
</ul>
<blockquote>
<pre><code>WWW-Authenticate: Digest realm=&quot;testrealm@host.com&quot;,
qop=&quot;auth,auth-int&quot;,
nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;,
opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot;
</code></pre></blockquote>
<ul>
<li>其中的 nonce 为服务器端生成的随机数，然后，客户端做 HASH1=MD5(MD5(username:realm:password):nonce:cnonce) ，其中的 cnonce 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。</li>
<li>如果 qop 中包含了 auth ，那么还得做  HASH2=MD5(method:digestURI) 其中的 method 就是HTTP的请求方法（GET/POST…），digestURI 是请求的URL。</li>
<li>如果 qop 中包含了 auth-init ，那么，得做  HASH2=MD5(method:digestURI:MD5(entityBody)) 其中的 entityBody 就是HTTP请求的整个数据体。</li>
<li>然后，得到 response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2) 如果没有 qop则 response = MD5(HA1:nonce:HA2)</li>
<li>最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 Authorization: Digest …<blockquote>
<pre><code>GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username=&quot;Mufasa&quot;,
 realm=&quot;testrealm@host.com&quot;,
 nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;,
 uri=&quot;%2Fcoolshell%2Fadmin&quot;,
 qop=auth,
 nc=00000001,
 cnonce=&quot;0a4f113b&quot;,
 response=&quot;6629fae49393a05397450978507c4ef1&quot;,
 opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot;
</code></pre><p>维基百科上的 Wikipedia: Digest access authentication 词条非常详细地描述了这个细节。</p>
</blockquote>
</li>
</ul>
<p>摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是，<strong>别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击</strong>——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。</p>
<h2 id="App-Secret-Key-HMAC"><a href="#App-Secret-Key-HMAC" class="headerlink" title="App Secret Key + HMAC"></a>App Secret Key + HMAC</h2><p>先说HMAC技术，这个东西来自于MAC – Message Authentication Code，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC – Hash-based Authenticsation Code，指的是利用Hash技术完成这一工作，比如：SHA-256算法。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2019/05/MAC-1024x634.png" alt=""></p>
<p>（图片来自 Wikipedia – MAC 词条 ）</p>
<p>我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。</p>
<p>把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过S3的API请求签名文档看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤：</p>
<ul>
<li>把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 CanonicalRequest，作个SHA-256的签名，然后再做一个base16的编码</li>
<li>把上面的这个签名和签名算法 AWS4-HMAC-SHA256、时间戳、Scop，再打一个包，叫 StringToSign。</li>
<li>准备签名，用 AWSSecretAccessKey来对日期签一个 DataKey，再用 DataKey 对要操作的Region签一个 DataRegionKey ，再对相关的服务签一个DataRegionServiceKey ，最后得到 SigningKey.</li>
<li>用第三步的 SigningKey来对第二步的 StringToSign 签名。</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2019/05/sigV4-using-query-params.png" alt=""></p>
<ul>
<li>最后，发出HTTP Request时，在HTTP头的 Authorization字段中放入如下的信息：</li>
</ul>
<blockquote>
<pre><code>Authorization: AWS4-HMAC-SHA256 
Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, 
SignedHeaders=content-type;host;x-amz-date, 
Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7
</code></pre></blockquote>
<p>其中的  AKIDEXAMPLE 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《Amazon S3 Rest API with curl》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。</p>
<p>这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： Acquia 的 HMAC，微信的签名算法 （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 Authorization 里，而是放在body里）</p>
<h2 id="JWT-–-JSON-Web-Tokens"><a href="#JWT-–-JSON-Web-Tokens" class="headerlink" title="JWT – JSON Web Tokens"></a>JWT – JSON Web Tokens</h2><p>JWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（Message Authentication Code）的方法。JWT的签名流程一般是下面这个样子：</p>
<ol>
<li>用户使用用户名和口令到认证服务器上请求认证。</li>
<li>认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下：<ul>
<li>认证服务器还会生成一个 Secret Key（密钥）</li>
<li>对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。</li>
<li>用密钥对JWT签名 HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+’.’+Base64UrlEncode(JWT-Payload));</li>
</ul>
</li>
</ol>
<p>3.然后把 base64(header).base64(payload).signature 作为 JWT token返回客户端。</p>
<p>4.客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。</p>
<p>当应用服务器收到请求后：</p>
<ol>
<li>应用服务会检查 JWT  Token，确认签名是正确的。</li>
<li>然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。</li>
<li>认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。</li>
<li>认证服务器检查通过后，应用服务就可以认为这是合法请求了。</li>
</ol>
<p>我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC-SHA256的算法外，还支持RSA的非对称加密的算法。</p>
<p>使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。</p>
<p>最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。</p>
<p>这里强烈建议全文阅读 Anglar 大学的 《JSW：The Complete Guide to JSON Web Tokens》</p>
<h2 id="OAuth-1-0"><a href="#OAuth-1-0" class="headerlink" title="OAuth 1.0"></a>OAuth 1.0</h2><p>OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：RFC 5849 （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 OAuth Core 1.0 Revision A ，我在下面做个大概的描述。</p>
<p>根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。</p>
<ul>
<li>这个协议有三个角色：<ul>
<li>User（照片所有者-用户）</li>
<li>Consumer（第三方照片打印服务）</li>
<li>Service Provider（照片存储服务）</li>
</ul>
</li>
<li>这个协义有三个阶段：<ul>
<li>Consumer获取Request Token</li>
<li>Service Provider 认证用户并授权Consumer</li>
<li>Consumer获取Access Token调用API访问用户的照片</li>
</ul>
</li>
</ul>
<p>整个授权过程是这样的：</p>
<ol>
<li>Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret</li>
<li>当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）</li>
<li>Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）</li>
<li>Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。</li>
<li>Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （oauth_token）和 Verification Code（oauth_verifier）</li>
<li>接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)</li>
<li>最后使用Access Token 访问用户授权访问的资源。<br>下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。</li>
</ol>
<p><img src="https://coolshell.cn/wp-content/uploads/2019/05/oauth_graph.gif" alt=""></p>
<p>因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示：</p>
<ol>
<li>Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret</li>
<li>Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）</li>
<li>Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）</li>
<li>Consumer 收到 Request Token 后，直接换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)</li>
<li>最后使用Access Token 访问用户授权访问的资源。<br>最后，再来说一说OAuth中的签名。</li>
</ol>
<ul>
<li>我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。</li>
<li>签名密钥就是由这两具密钥拼接而成的，其中用 &amp;作连接符。假设 Consumer Secret 为 j49sk3j29djd 而 Token Secret 为dh893hdasih9那个，签名密钥为：j49sk3j29djd&amp;dh893hdasih9</li>
<li>在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如：<ul>
<li>Consumer Key ： 也就是所谓的AppID</li>
<li>Token： Request Token 或 Access Token</li>
<li>Signature Method ：签名算法比如：HMAC-SHA1</li>
<li>Timestamp：过期时间</li>
<li>Nonce：随机字符串</li>
<li>Call Back：回调URL<br>下图是整个签名的示意图：</li>
</ul>
</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2019/05/oauth_singature.png" alt=""></p>
<p>图片还是比较直观的，我就不多解释了。</p>
<h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求，<strong>这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制</strong>，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。</p>
<p>这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 RFC 6749 正式放出。</p>
<p><strong>OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的。</strong>目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。</p>
<p>下面，我们来重点看一下OAuth 2.0的两个主要的Flow：</p>
<ul>
<li>一个是Authorization Code Flow， 这个是 3 legged 的</li>
<li>一个是Client Credential Flow，这个是 2 legged 的。<h3 id="Authorization-Code-Flow"><a href="#Authorization-Code-Flow" class="headerlink" title="Authorization Code Flow"></a>Authorization Code Flow</h3>Authorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2019/05/auth_code_flow.png" alt=""></p>
<p>下面是对这个流程的一个细节上的解释：</p>
<p>1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 /authorize API，其中的请求方式如下所示。</p>
<blockquote>
<pre><code>https://login.authorization-server.com/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&amp;response_type=code
&amp;redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F
&amp;scope=read
&amp;state=xcoiv98CoolShell3kch
</code></pre><p>其中：</p>
</blockquote>
<ul>
<li>client_id为第三方应用的App ID</li>
<li>response_type=code为告诉认证服务器，我要走Authorization Code Flow。</li>
<li>redirect_uri意思是我跳转回第三方应用的URL</li>
<li>scope意是相关的权限</li>
<li>state 是一个随机的字符串，主要用于防CSRF攻击。</li>
</ul>
<p>2）当Authorization Server收到这个URL请求后，其会通过 client_id来检查 redirect_uri和 scope是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。</p>
<p>3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示：</p>
<blockquote>
<pre><code>https://example-client.com/callback?
code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&amp;state=xcoiv98CoolShell3kch
</code></pre><p>我们可以看到，</p>
</blockquote>
<p>请流动的链接是第 1）步中的 redirect_uri<br>其中的 state 的值也和第 1）步的 state一样。</p>
<p>4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。</p>
<blockquote>
<pre><code>POST /oauth/token HTTP/1.1
Host: authorization-server.com

code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&amp;grant_type=code
&amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F
&amp;client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&amp;client_secret=JqQX2PNo9bpM0uEihUPzyrh
</code></pre></blockquote>
<p>5）如果没什么问题，Authorization 会返回如下信息。</p>
<blockquote>
<pre><code>{
  &quot;access_token&quot;: &quot;iJKV1QiLCJhbGciOiJSUzI1NiI&quot;,
  &quot;refresh_token&quot;: &quot;1KaPlrEqdFSBzjqfTGAMxZGU&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600,
  &quot;id_token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM...&quot;
}
</code></pre><p>其中，</p>
</blockquote>
<ul>
<li>access_token就是访问请求令牌了</li>
<li>refresh_token用于刷新 access_token</li>
<li>id_token 是JWT的token，其中一般会包含用户的OpenID</li>
</ul>
<p>6）接下来就是用 Access Token 请求用户的资源了。</p>
<blockquote>
<pre><code>GET /v1/user/pictures
Host: https://example.resource.com

Authorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI
</code></pre></blockquote>
<h3 id="Client-Credential-Flow"><a href="#Client-Credential-Flow" class="headerlink" title="Client Credential Flow"></a>Client Credential Flow</h3><p>Client Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。<br><img src="https://coolshell.cn/wp-content/uploads/2019/05/client_credentials_flow.png" alt=""></p>
<p>这个过程非常简单，本质上就是Client用自己的 client_id和 client_secret向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。</p>
<p>请求示例</p>
<blockquote>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&amp;client_id=czZCaGRSa3F0Mzpn
&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
</code></pre><p>返回示例</p>
<pre><code>{
  &quot;access_token&quot;:&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;,
  &quot;token_type&quot;:&quot;bearer&quot;,
  &quot;expires_in&quot;:3600,
  &quot;refresh_token&quot;:&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;,
  &quot;scope&quot;:&quot;create&quot;
}
</code></pre><p>这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“微信公众号获取access token”），我截了个图如下所谓。我们可以看到，微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret……</p>
</blockquote>
<p> <img src="https://coolshell.cn/wp-content/uploads/2019/05/wechat.dev_-1024x876.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>讲了这么多，我们来小结一下（下面的小结可能会有点散）</p>
<h3 id="两个术语和三个概念"><a href="#两个术语和三个概念" class="headerlink" title="两个术语和三个概念"></a>两个术语和三个概念</h3><ul>
<li>区分两个术语：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。</li>
<li>区分三个概念：编码Base64Encode、签名HMAC、加密RSA。Base64编码是为了更好的传输（没有怪异的字符，可以传输二进制文件），等同于明文，HMAC签名是为了信息不能被篡改，RSA加密是为了不让别人看到是什么信息。<h3 id="明白一些初衷"><a href="#明白一些初衷" class="headerlink" title="明白一些初衷"></a>明白一些初衷</h3></li>
<li>使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。</li>
<li>JWT把 uid 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。</li>
<li>OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。</li>
<li>用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。</li>
<li>OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。<h3 id="相关的注意事项"><a href="#相关的注意事项" class="headerlink" title="相关的注意事项"></a>相关的注意事项</h3></li>
<li>无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 Authorization HTTP 头中。</li>
<li>不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。</li>
<li>密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。</li>
<li>HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。</li>
<li>最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。</li>
<li>使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。</li>
<li>密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。</li>
<li>认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。</li>
</ul>
<p>(全文完)</p>
<p>原文链接： <a href="https://coolshell.cn/articles/19395.html" title="HTTP API 认证授权术" target="_blank" rel="external">HTTP API 认证授权术</a></p>
<p>原文姊妹篇链接：<a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="external">《网络数字身份认证术》</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2023/05/16/talk-about-teamwork-and-collaboration-tools/" itemprop="url">
                  聊聊团队协同和协同工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2023-05-16T17:04:00+08:00" content="2023-05-16">
              2023-05-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/产品研究/" itemprop="url" rel="index">
                    <span itemprop="name">产品研究</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两天跟 Cali 和 Rather 做了一个线上的 Podcast – Ep.5 一起聊聊团队协同。主要是从 IM 工具扩展开来聊了一下团队的协同和相应的工具，但是聊天不是深度思考，有一些东西我没有讲透讲好，所以，我需要把我更多更完整更结构化的想法形成文字。（注：聊天聊地比较详细，本文只是想表达我的主要想法）</p>
<h2 id="国内外的企业-IM-的本质差别"><a href="#国内外的企业-IM-的本质差别" class="headerlink" title="国内外的企业 IM 的本质差别"></a>国内外的企业 IM 的本质差别</h2><p>国内企业级在线交流工具主要有：企业微信、钉钉、飞书，国外的则是：Slack、Discord这两大IM工具，你会发现，他们有很多不一样的东西，<strong>其中有两个最大的不同，一个是企业管理，一个是企业文化。</strong></p>
<h3 id="企业管理"><a href="#企业管理" class="headerlink" title="企业管理"></a>企业管理</h3><p><strong>Slack/Discrod 主要是通过建 Channel ，而国内的IM则主要是拉群。</strong>你可能会说，这不是一样的吗？其实是不一样的，很明显，Channel 的属性是相对持久的，而群的属性则是临时的，前者是可以是部门，可以是团队，可以是项目，可以是产品，可以是某种长期存在的职能（如：技术分享），而拉群则是相对来说临时起意的，有时候，同样的人群能被重复地拉出好几次，因为之前临时起意的事做完了，所以群就被人所遗忘了，后面再有事就再来。<strong>很明显，Channel 这种方式明显是有管理的属性的，而拉群则是没有管理的。</strong></p>
<p>所以，在国内这种作坊式，野蛮粗放式的管理风格下，他们需要的就是想起一出是一出的 IM 工具，所以，拉群就是他们的工作习惯，因为没有科学的管理，所以没有章法，所以，他们不需要把工作内的信息结构化的工具。而国外则不然，国外的管理是精细化的，国外的公司还在重度使用 Email 的通讯方式，而 Email 是天生会给一个主题时行归类，而且 Email 天生不是碎片信息，所以，国外的 IM 需要跟 Email 竞争，因为像 Email 那样给邮件分类，把信息聚合在一个主题下的方式就能在 IM 上找到相关的影子。Channel 就是一个信息分类，相当于邮件分类，Slack 的 回复区和 Discord 的子区就像是把同一个主题信息时行聚合的功能。这明显是懂管理的人做的，而国内的拉群一看就是不懂管理的人干的，或者说是就是满足这些不懂管理的人的需求的。</p>
<h3 id="企业文化"><a href="#企业文化" class="headerlink" title="企业文化"></a>企业文化</h3><p>团队协作和团队工作最大的基石是信任，如果有了信任，没有工具都会很爽，如果没有信任，什么工具都没用。信任是一种企业文化，这种文化不仅包括同级间的，还包括上下级间的。但是，因为国内的管理跟不上，所以，就导致了各种不信任的文化，而需要在这里不信任的文化中进行协同工作，国内的 IM 软件就会开发出如下在国外的 IM 中完全没有的功能：</p>
<ul>
<li><strong>监控员工。</strong>获取员工的工作时间以及工作位置。</li>
<li><strong>有详细的已读标注。</strong>这样会给对方要回复的压力。</li>
<li><strong>发出的信息不能修改，不能删除，非常有限地可撤回。</strong></li>
</ul>
<p>而国外的 IM 则是，发出的信息可以修改/删除，没有已读标准，也不会监控员工。这种时候，我总是会对工作在这种不信任文化中人感到可怜……如果大家需要靠逼迫的方式把对方拉来跟我一起协作，我们还工作个什么劲啊。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>所以，我们可以看到，<strong>畸形的企业管理和企业文化下，就会导致畸形的协同工具。</strong>最令人感到悲哀的是，有好多同学还觉得国内的钉钉非常之好，殊不知，你之所以感觉好用，是因为你所在的环境是如此的不堪。你看，<strong>人到了不同的环境就会有不同的认识，所以，找一个好一些的环境对一个人的成长有多重要。</strong></p>
<p>给一些新入行的人的建议就是，一个环境对一个人的认知会有非常大的影响，找一个好的环境是非常重要，如果不知道什么 环境是好的，那就先从不使用钉钉为工作协同软件的公司开始吧……</p>
<h2 id="什么是好的协同工具"><a href="#什么是好的协同工具" class="headerlink" title="什么是好的协同工具"></a>什么是好的协同工具</h2><p>我们从上面可以得到，协同的前提条件是你需要有一个基于信任的企业文化，还需要有有结构化思维的科学的管理思维。没有这两个东西，给你的团队再多的工具都不可能有真正好有协同的，大家就是装模作样罢了。</p>
<p>假设我们的管理和文化都没有问题，那下面我们来谈谈协同工具的事。</p>
<p>我个人觉得 IM 这种工具包括会议都不是一种好的协同工具，因为这些工具都无法把信息做到真正的结构化和准确化，用 IM 或是开会上的信息大多都是碎片化严重，而且没有经过深度思考或是准备的，基本都是即兴出来的东西，不靠谱的概率非常大。</p>
<p>找人交流和开会不是有个话题就好的，还需要一个可以讨论的“议案”。在 Amazon 里开会，会前，组织方会把要讨论的方案打印出来给大家看，这个方案是深思过的，是验证过的，是有数据和证据或是引用支撑的，会议开始后，10 -15分钟是没有人说话的，大家都在看文档，然后就开始直接讨论或发表意见，支持还是不支持，还是有条件支持……会议效率就会很高。</p>
<p>但是这个议案其实是可以由大家一起来完成的，所以，连打印或是开会都不需要。试想一下，使用像 Google Doc 这样的协同文档工具，把大家拉到同一个文档里直接创作，不香吗？我在前段时间，在公网上组织大家来帮我完成一个《非常时期的囤货手册》，这篇文章的形成有数百个网友的加持，而我就是在做一个主编的工作，这种工作是 IM 工具无法完成的事。与之类似的协同工具还有大家一起写代码的 Github，大家一起做设计的 Figma……这样创作类的协同工具非常多。另外，好多这些工具都能实时展示别人的创作过程，这个简直是太爽了，你可以通过观看他人创作过程，学习到很多他人的思路和想法，这个在没有协同工具的时代是很难想像的。</p>
<p>好的协同工具是可以互相促进互相激励的，就像一个足球队一样，当你看到你的队友在勇敢地争抢，拼命地奔跑，你也会被感染到的。</p>
<p>所以，<strong>好的协同就是能够跟一帮志同道合，有共同目标，有想法，有能力的人一起做个什么事。所以，在我心中我最喜欢的协同工具从来都是创作类的，不是管理类的，更不是聊天类的。</strong>管理和聊天的协同软件会让你产生一种有产出的假象，但其实不同，这种工具无论做的有多好，都是支持性的工具，不是产出类的工具，不会提升生产力的。</p>
<p>另外，在创作类的协同工具上如果有一些智能小帮手，如：Github 发布的 Copilot。那简直是让人爽翻天了，所以，真正能提升生产力的工具都是在内容上帮得到你的。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我其实并不喜欢今天所有的 IM 工具，因为我觉得信息不是结构化的，信息是有因果关系和上下文的，是结构化的，是多维度的，不是今天这种线性的方式，我们想像一下“脑图”或是知识图，或是 wikipedia 的网关的关联，我们可能就能想像得到一个更好的 IM 应该是什么 样的……</p>
<p>协同工作的想像空间实在是太大了，我觉得所有的桌面端的软件都会被协作版的重写，虽然，这种协作软件需要有网络的加持，但是协作软件的魅力和诱惑力实在的太大了，让人无法不从……</p>
<p>未来的企业，那些管理类的工具一定会被边缘化的，聊天类的会被打成一个通知中心，而创作类的会大放异彩，让大家直接在要干的事上进行沟通、交互和分享。</p>
<p>（全文完）</p>
<p>原文链接：<a href="https://coolshell.cn/articles/22298.html" title="聊聊团队协同和协同工具" target="_blank" rel="external">聊聊团队协同和协同工具</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2022/08/21/How-to-use-FSOCKOPEN-in-PHP-to-achieve-asynchronous-request-and-response-status-code-499/" itemprop="url">
                  PHP中怎么使用fsockopen实现异步请求与响应状态码499
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2022-08-21T01:46:00+08:00" content="2022-08-21">
              2022-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web构建/" itemprop="url" rel="index">
                    <span itemprop="name">Web构建</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>在PHP中使用fsockopen实现异步请求时，发现请求有发出，但是响应不是200而是499，导致被请求脚本并未按要求执行。</p>
<h3 id="这个问题的起源与解决方案。"><a href="#这个问题的起源与解决方案。" class="headerlink" title="这个问题的起源与解决方案。"></a>这个问题的起源与解决方案。</h3><p>php中怎么使用fsockopen实现异步请求，相信很多没有经验的人对此束手无策，为此本文总结了问题出现的原因和解决方法，通过这篇文章希望你能解决这个问题。</p>
<p>php执行一段程序，有可能几毫秒就执行完毕，也有可能耗时较长。</p>
<p>例如，用户下单这个事件，如果调用了些第三方服务进行发邮件、短信、推送等通知，可能导致前端一直在等待。</p>
<p>而有的时候，我们并不关心这些耗时脚本的返回结果，只要执行就行了。这时候就需要采用异步的方式执行。</p>
<p>众所周知，PHP没有直接支持多线程这种东西。我们可以采用折衷的方式实现。这里主要说的就是fsockopen。</p>
<p>通过fsockopen发送请求并忽略返回结果，程序可以马上返回。</p>
<p>示例代码：</p>
<pre><code>$fp = fsockopen(&quot;www.example.com&quot;, 80, $errno, $errstr, 30);
if (!$fp) {
       echo &quot;$errstr ($errno)&lt;br /&gt;\n&quot;;
} else {
       $out = &quot;GET /backend.php   HTTP/1.1\r\n&quot;;
    $out .= &quot;Host: www.example.com\r\n&quot;;
    $out .= &quot;Connection: Close\r\n\r\n&quot;;

    fwrite($fp, $out);
    /*忽略执行结果
    while (!feof($fp)) {
        echo fgets($fp, 128);
    }*/
       fclose($fp);
}
</code></pre><p>需要注意的是我们需要手动拼出header头信息。通过打开注释部分，可以查看请求返回结果，但这时候又变成同步的了，因为程序会等待返回结果才结束。</p>
<h3 id="实际测试遇到的问题"><a href="#实际测试遇到的问题" class="headerlink" title="实际测试遇到的问题"></a>实际测试遇到的问题</h3><p>实际测试的时候发现，不忽略执行结果，调试的时候每次都会成功发送sock请求；但忽略执行结果，经常看到没有成功发送sock请求。查看nginx日志，发现很多状态码为499的请求。</p>
<p>后来找到了原因：</p>
<p><code>fwrite</code>之后马上执行<code>fclose</code>，nginx会直接返回499，不会把请求转发给php处理。</p>
<p>客户端主动端口请求连接时，NGINX 不会将该请求代理给上游服务（FastCGI PHP 进程），这个时候 access log 中会以 499 记录这个请求。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1)nginx.conf增加配置</p>
<pre><code>#忽略客户端中断
fastcgi_ignore_client_abort on;
</code></pre><p>2)fwrite之后使用usleep函数休眠20毫秒：</p>
<pre><code>usleep(20000);
</code></pre><p>后来测试就没有发现失败的情况了。</p>
<hr>
<p>相关链接：</p>
<p><a href="https://www.yisu.com/zixun/367919.html" title="参考文章1" target="_blank" rel="external">参考文章1</a></p>
<p><a href="https://blog.csdn.net/panjiapengfly/article/details/103010517" title="参考文章2" target="_blank" rel="external">参考文章2</a></p>
<p><a href="https://blog.csdn.net/wang_quan_li/article/details/41806529" title="参考文章3" target="_blank" rel="external">参考文章3</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2022/05/31/online-capacity-expansion-of-cloud-disks/" itemprop="url">
                  云盘在线扩容
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2022-05-31T11:15:00+08:00" content="2022-05-31">
              2022-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在线扩容，是在磁盘不够用时，直接不停机不停服的情况下扩展磁盘空间。</p>
<p>非常好用。不过，需要系统支持。</p>
<h3 id="一、扩容概述（官网说明）"><a href="#一、扩容概述（官网说明）" class="headerlink" title="一、扩容概述（官网说明）"></a>一、扩容概述（官网说明）</h3><p><a href="https://help.aliyun.com/document_detail/35095.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/35095.html</a></p>
<p>这个是是前提，包括：扩容场景、系统盘扩容上限、数据盘扩容上限、扩容计费等。<br>是在进行技术操作前的一些须知与准备工作。<br>确认在用的ECS实例与云盘支持“在线扩容”之后，才能进行后续的操作。</p>
<h3 id="二、在线扩容云盘（Linux系统）（官网说明）"><a href="#二、在线扩容云盘（Linux系统）（官网说明）" class="headerlink" title="二、在线扩容云盘（Linux系统）（官网说明）"></a>二、在线扩容云盘（Linux系统）（官网说明）</h3><p><a href="https://help.aliyun.com/document_detail/113316.htm" target="_blank" rel="external">https://help.aliyun.com/document_detail/113316.htm</a></p>
<p>这个是具体的执行Linux系统的云盘“在线扩容”的详细步骤。<br>包括：前提条件，背景信息，操作步骤，支持在线扩容的操作系统，常见问题，其他扩容场景。</p>
<p>其中【操作步骤】又包括：<br>步骤一：创建快照；<br>步骤二：在控制台扩容云盘容量；<br>步骤三：查看云盘分区情况；<br>步骤四：扩容分区；<br>步骤五：扩容文件系统。</p>
<h3 id="三、实际操作步骤【关键】（实际操作）"><a href="#三、实际操作步骤【关键】（实际操作）" class="headerlink" title="三、实际操作步骤【关键】（实际操作）"></a>三、实际操作步骤【关键】（实际操作）</h3><p>1、例子：扩容/dev/vda 由80G扩容到160G</p>
<p>在阿里云上进行在线扩容操作 ：</p>
<p>存储与快照 &gt; 云盘页面选择云盘后，单击云盘扩容，选中在线扩容，并设置扩容后容量<br>Linux上执行命令</p>
<p>2、查看磁盘信息：<code>fdisk -l</code></p>
<p>3、查看要扩容的分区的文件系统类型：<code>df -hT</code></p>
<p>4、安装growpart工具<br>CentOS 7及以上版本：运行命令 <code>yum install cloud-utils-growpart</code><br>Debian 9及以上版本、Ubuntu14及以上版本：运行命令 <code>apt install -y cloud-guest-utils</code></p>
<p>5、运行命令，扩容分区：<code>growpart /dev/vda 1</code>（1前面有空格）</p>
<p>6、扩容文件系统：<code>resize2fs /dev/vda1</code> （这里1前面没有空格）</p>
<p>7、查看是否扩容成功：<code>df -hT</code></p>
<h3 id="四、几个问题的解决"><a href="#四、几个问题的解决" class="headerlink" title="四、几个问题的解决"></a>四、几个问题的解决</h3><p>1、问题出现在上述详细步骤的“4、安装growpart工具”这一步，由于CentOS8不再被支持，而造成了yum源错误的问题。</p>
<p>错误提示为：</p>
<p><code>Error:Failed to download metadata for repo &#39;AppStream&#39;</code></p>
<p>解决方案：</p>
<p>由于CentOS 8操作系统版本结束了生命周期而导致YUM源出错的问题：<br><a href="https://help.aliyun.com/document_detail/405635.htm" target="_blank" rel="external">https://help.aliyun.com/document_detail/405635.htm</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2022/04/27/type-of-Apple-developer-account-and-distribution-method/" itemprop="url">
                  苹果开发者账号的类型与发布方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2022-04-27T16:42:00+08:00" content="2022-04-27">
              2022-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ios/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>苹果开发者账号的类型与发布方式</p>
<h2 id="开发者账号类型"><a href="#开发者账号类型" class="headerlink" title="开发者账号类型"></a>开发者账号类型</h2><p>苹果开发者账号有个人版（99美金/年），公司版（99美金/年）和企业版（299美金/年）三种。</p>
<p><strong>99美金属于标准计划；</strong></p>
<p>标准计划还分为标准个人计划和标准公司计划，区别是：如登记为标准个人计划（个人开发者），则应用程序商店中的“seller name”将显示您个人的名称，如登记为标准公司计划（公司开发者）则应用程序商店中的“seller name”将显示公司的法定名称，同时您可以把其他会员添加到开发团队。</p>
<p><strong>299美金属于企业计划。</strong></p>
<h3 id="一、99美金个人开发者账号："><a href="#一、99美金个人开发者账号：" class="headerlink" title="一、99美金个人开发者账号："></a>一、99美金个人开发者账号：</h3><p>1、开发者能够自由地创造iPhone / iPod Touch/ iPad的商业应用，并且能够发布他们的应用程序（免费或收费）在App Store上</p>
<p>2、App Store中的“seller name”将显示您个人的名称</p>
<p>3、每年可以设置100台测试机做开发及测试用</p>
<p>4、不允许开发人员创建一个团队</p>
<h3 id="二、99美金公司开发者账号："><a href="#二、99美金公司开发者账号：" class="headerlink" title="二、99美金公司开发者账号："></a>二、99美金公司开发者账号：</h3><p>1、开发者能够自由地创造iPhone / iPod Touch/ iPad的商业应用，并且能够发布他们的应用程序（免费或收费）在App Store上</p>
<p>2、App Store中的“seller name”将显示公司的法定名称</p>
<p>3、每年可以设置100台测试机做开发及测试用</p>
<p>4、允许开发人员创建一个团队，可以把其他成员添加到开发团队</p>
<p>5、公司应在邓白氏注册并拥有有效的DUNS号码</p>
<p>删除Provisioning Profiles,appid,发布证书的后果:</p>
<blockquote>
<p>如果app已经上线发布至App Store了，那么此时删除开发者账号的证书和描述文件对已经上线的app来说没什么大的影响，app可以正常使用。如果app在开发阶段，此时删除证书和描述文件，应该是不行的，上架估计都不会通过。</p>
<p>没有实际测试过</p>
</blockquote>
<h3 id="三、299美金企业开发者账号："><a href="#三、299美金企业开发者账号：" class="headerlink" title="三、299美金企业开发者账号："></a>三、299美金企业开发者账号：</h3><p>1、不允许该企业在App Store出售他们的应用程序</p>
<p>2、所开发的应用只能发给其雇员作内部使用</p>
<p>3、UDID数量不限制</p>
<p>4、允许开发人员创建一个团队，团队成员添加到他们的帐户</p>
<p>5、公司应在邓白氏注册并拥有有效的DUNS号码（面向拥有500雇员以上的公司）</p>
<p>删除Provisioning Profiles,appid,发布证书的后果:</p>
<blockquote>
<p>所有已经安装的app不能打开，会闪退，在线itms-services协议不能安装</p>
<p>所以企业应用安装到手机上则需要开发者账号上的证书和描述文件来通过手机的验证，此时删除证书和描述文件，则无法通过手机的验证，app也就无法使用了。此时下载的话则无法进行安装，会显示Unable to download app，选择Done或Retry。</p>
<p>但是我测试了删除了appid和发布证书,app没有任何影响,放在fir还是能下载安装,不知道是不是删除时间太短(删除3天了  还是能用)</p>
</blockquote>
<h2 id="发布方式（4种）："><a href="#发布方式（4种）：" class="headerlink" title="发布方式（4种）："></a>发布方式（4种）：</h2><h3 id="一、苹果应用商店发布（App-Store）"><a href="#一、苹果应用商店发布（App-Store）" class="headerlink" title="一、苹果应用商店发布（App Store）"></a>一、苹果应用商店发布（App Store）</h3><h3 id="二、苹果应用商店批量购买发布（Volume-Purchase-Program）"><a href="#二、苹果应用商店批量购买发布（Volume-Purchase-Program）" class="headerlink" title="二、苹果应用商店批量购买发布（Volume Purchase Program）"></a>二、苹果应用商店批量购买发布（Volume Purchase Program）</h3><h3 id="三、In-House企业应用发布："><a href="#三、In-House企业应用发布：" class="headerlink" title="三、In-House企业应用发布："></a>三、In-House企业应用发布：</h3><p>1、不能提交到App Store</p>
<p>2、发布应用的具体内容不需要苹果官方审核</p>
<p>3、安装设备的数量没有任何限制</p>
<p>4、把程序放在网站中，提供给最终用户一个链接，他们就能够直接下载并自动安装了</p>
<h3 id="四、Ad-Hoc应用发布方式"><a href="#四、Ad-Hoc应用发布方式" class="headerlink" title="四、Ad Hoc应用发布方式"></a>四、Ad Hoc应用发布方式</h3><p>1、不能提交到App Store</p>
<p>2、不需要经过苹果的评审，</p>
<p>3、限制每个应用不能发布到超过100个设备上</p>
<p>4、把程序放在网站中，提供给最终用户一个链接，他们就能够直接下载并自动安装了</p>
<p>（全文完）</p>
<p><a href="https://www.jianshu.com/p/87d9e4259846" target="_blank" rel="external">原文链接</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/08/15/linux-finds-and-move-files/" itemprop="url">
                  linux查找并移动文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-08-15T11:48:00+08:00" content="2021-08-15">
              2021-08-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>linux查找并移动文件</p>
<h3 id="原文参考"><a href="#原文参考" class="headerlink" title="原文参考"></a>原文参考</h3><pre><code>find . -name &apos;10-*.dat&apos; -exec mv {} ../ \;
</code></pre><p>这里：</p>
<p>=&gt; -exec mv {} /mnt/mp3 \; - 运行mv命令。</p>
<p>=&gt; {} - 字符 ‘{}’ 代表find到的所有内容。</p>
<p>=&gt;../表示当前用户目录的上一级目录</p>
<p>=&gt; \; - 结束 /bin/mv 命令。</p>
<h3 id="亲测可用"><a href="#亲测可用" class="headerlink" title="亲测可用"></a>亲测可用</h3><p>移动搜索匹配条件的文件到指定目录</p>
<p>查找并移动</p>
<pre><code>find . -name &apos;faverifyimage_*.png&apos; -exec mv {} ../ \;
</code></pre><p>只查找</p>
<pre><code>find . -name &apos;faverifyimage_*.png&apos;;
</code></pre><p>以下命令是：</p>
<p>移动【当前目录下（不含子目录）】【以faverifyimage_开头的图片文件】到【faverifyimgbk】目录。</p>
<p>说明：扩展了“不含子目录”这个条件，只操作“当前目录”；同时，继续执行了其他格式的图片文件。</p>
<pre><code>find . -maxdepth 1 -name &apos;faverifyimage_*.png&apos; -exec mv {} ./faverifyimgbk \;
find . -maxdepth 1 -name &apos;faverifyimage_*.jpg&apos; -exec mv {} ./faverifyimgbk \;
find . -maxdepth 1 -name &apos;faverifyimage_*.jpeg&apos; -exec mv {} ./faverifyimgbk \;
</code></pre><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<p>之后好久没更新。</p>
<h1 id="因为github在2021年08月13日之后停止了账号密码的登录机制。"><a href="#因为github在2021年08月13日之后停止了账号密码的登录机制。" class="headerlink" title="因为github在2021年08月13日之后停止了账号密码的登录机制。"></a>因为github在2021年08月13日之后停止了账号密码的登录机制。</h1><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1005c8acaffa52e5d81b9fff2815f3f1febb6fdc
　　</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/06/07/PHP-floating-point-calculations-must-use-the-high-precision-calculation-functions-provided-by-PHP/" itemprop="url">
                  PHP浮点数计算必须使用PHP提供的高精度计算函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2021-06-07T10:38:00+08:00" content="2021-06-07">
              2021-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术日记/" itemprop="url" rel="index">
                    <span itemprop="name">技术日记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前方有坑"><a href="#一、前方有坑" class="headerlink" title="一、前方有坑"></a>一、前方有坑</h3><p>php在使用加减乘除等运算符计算浮点数的时候，经常会出现意想不到的结果，特别是关于财务数据方面的计算，给不少工程师惹了很多的麻烦。比如今天工作终于到的一个案例：</p>
<pre><code>$a = 2586;

$b = 2585.98;

var_dump($a-$b);
</code></pre><p>期望的结果是：float(0.02)</p>
<p>实际结果：</p>
<pre><code>float(0.019999999999982)
</code></pre><p>人生有坑，处处提防</p>
<h3 id="二、防坑攻略："><a href="#二、防坑攻略：" class="headerlink" title="二、防坑攻略："></a>二、防坑攻略：</h3><p>1、通过乘100的方式转化为整数加减，然后在除以100转化回来……</p>
<p>2、使用number_format转化成字符串，然后在使用（float）强转回来……</p>
<p>3、php提供了高精度计算的函数库，实际上就是为了解决这个浮点数计算问题而生的。</p>
<p>主要函数有：</p>
<p>bcadd — 将两个高精度数字相加</p>
<p>bccomp — 比较两个高精度数字，返回-1, 0, 1</p>
<p>bcdiv — 将两个高精度数字相除</p>
<p>bcmod — 求高精度数字余数</p>
<p>bcmul — 将两个高精度数字相乘</p>
<p>bcpow — 求高精度数字乘方</p>
<p>bcpowmod — 求高精度数字乘方求模，数论里非常常用</p>
<p>bcscale — 配置默认小数点位数，相当于就是Linux bc中的”scale=”</p>
<p>bcsqrt — 求高精度数字平方根</p>
<p>bcsub — 将两个高精度数字相减</p>
<p>前两种流氓的办法就不测试了，使用bcsub测试第三种两数相减的例子，</p>
<p>先看bcsub用法（来自官网）</p>
<pre><code>string bcsub ( string $left_operand , string $right_operand [, int $scale = int ] )

参数

left_operand 字符串类型的左操作数.

right_operand 字符串类型的右操作数.

scale 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。

返回值 返回减法之后结果为字符串类型.
</code></pre><p>测试代码：</p>
<pre><code>var_dump(bcsub($a,$b,2));
</code></pre><p>结果</p>
<pre><code>0.02
</code></pre><p>其他的函数请参考PHP官方网站</p>
<h3 id="三、为啥有坑："><a href="#三、为啥有坑：" class="headerlink" title="三、为啥有坑："></a>三、为啥有坑：</h3><p>php的bug?不是，这是所有语言基本上都会遇到的问题，所以基本上大部分语言都提供了精准计算的类库或函数库。</p>
<p>要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754):</p>
<p>浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位).</p>
<p>符号位：最高位表示数据的正负，0表示正数，1表示负数。</p>
<p>指数位：表示数据以2为底的幂，指数采用偏移码表示</p>
<p>尾数：表示数据小数点后的有效数字.</p>
<p>这里的关键点就在于, 小数在二进制的表示, 小数如何转化为二进制呢？</p>
<p>算法是乘以2直到没有了小数为止。这里举个例子，0.9表示成二进制数</p>
<p>0.9*2=1.8 取整数部分 1</p>
<p>0.8(1.8的小数部分)*2=1.6 取整数部分 1</p>
<p>0.6*2=1.2 取整数部分 1</p>
<p>0.2*2=0.4 取整数部分 0</p>
<p>0.4*2=0.8 取整数部分 0</p>
<p>0.8*2=1.6 取整数部分 1</p>
<p>0.6*2=1.2 取整数部分 0</p>
<p>………</p>
<p>0.9二进制表示为(从上往下): 1100100100100……</p>
<p>注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了”减不尽”的精度丢失问题。</p>
<p>换句话说：我们看到十进制小数，在计算机内存储的不是一个精确的数字，也不可能精确。所以在数字加减乘除后出现意想不到的结果。</p>
<h3 id="四、防坑提示"><a href="#四、防坑提示" class="headerlink" title="四、防坑提示"></a>四、防坑提示</h3><p>基于以上原因，所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。</p>
<p>原文链接：<a href="https://www.cnblogs.com/kenshinobiy/p/10797902.html" target="_blank" rel="external">https://www.cnblogs.com/kenshinobiy/p/10797902.html</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="isunman" />
          <p class="site-author-name" itemprop="name">isunman</p>
          <p class="site-description motion-element" itemprop="description">love IT, love Movie, love Love</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">96</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">45</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/isunman" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/" target="_blank">知乎</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy;  2011 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">isunman</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="powered-by">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">
<span id="busuanzi_container_site_pv">
    PV<span id="busuanzi_value_site_pv"></span> --
</span>
<span id="busuanzi_container_site_uv">
  UV<span id="busuanzi_value_site_uv"></span>
</span>
</div>


      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  


  

</body>
</html>
