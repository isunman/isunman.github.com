<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>太阳侠</title>
  <subtitle>我是一颗恒星</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://isunman.com/"/>
  <updated>2025-03-13T08:09:25.961Z</updated>
  <id>http://isunman.com/</id>
  
  <author>
    <name>isunman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信公众号文章标题与封面图片提取失败的解决方案</title>
    <link href="http://isunman.com/2025/03/13/solutions-for-failed-extraction-of-mparticle-titles-and-cover-images/"/>
    <id>http://isunman.com/2025/03/13/solutions-for-failed-extraction-of-mparticle-titles-and-cover-images/</id>
    <published>2025-03-13T08:05:00.000Z</published>
    <updated>2025-03-13T08:09:25.961Z</updated>
    
    <content type="html">&lt;p&gt;原来写的算法【对微信公众号文章的链接直接提取标题与封面图片URL】突然失效了，就在今天2025年03月13日。&lt;br&gt;目前在我们产品中使用的场景还需要继续支持，需要修复。&lt;/p&gt;
&lt;p&gt;第一反应：在我系统中算法未更改的情况下，微信公众号文章的html页面结构有变化，导致原来的正则匹配算法失败了，也可能是微信确实优化了他们的&lt;strong&gt;反爬机制算法&lt;/strong&gt;，例如会通过JavaScript动态加载或验证请求头来限制数据抓取。&lt;/p&gt;
&lt;p&gt;现在AI大模型时代，直接让Poe与Claude与DeepSeek给出优化建议。&lt;/p&gt;
&lt;p&gt;对比与实测后，DeepSeek给的建议有效可用。&lt;/p&gt;
&lt;h3 id=&quot;DeepSeek的建议V1——仅标题&quot;&gt;&lt;a href=&quot;#DeepSeek的建议V1——仅标题&quot; class=&quot;headerlink&quot; title=&quot;DeepSeek的建议V1——仅标题&quot;&gt;&lt;/a&gt;DeepSeek的建议V1——仅标题&lt;/h3&gt;&lt;p&gt;由于微信公众号的部分公开文章在浏览器未登录时可以直接访问，但实际页面内容会通过 JavaScript动态加载 或 验证请求头 来限制数据抓取。以下是优化后的 PHP代码，通过更精准的请求头模拟和HTML解析策略实现标题提取：&lt;/p&gt;
&lt;h4 id=&quot;最终可执行代码（已验证有效）&quot;&gt;&lt;a href=&quot;#最终可执行代码（已验证有效）&quot; class=&quot;headerlink&quot; title=&quot;最终可执行代码（已验证有效）&quot;&gt;&lt;/a&gt;最终可执行代码（已验证有效）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php
function extractWechatTitle($url) {
    $ch = curl_init();

    // 关键：模拟完整浏览器请求头（包含移动端特征）
    $headers = [
        &amp;apos;User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&amp;apos;,
        &amp;apos;Referer: https://mp.weixin.qq.com/&amp;apos;,
        &amp;apos;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&amp;apos;,
        &amp;apos;Accept-Language: zh-CN,zh;q=0.9&amp;apos;,
        &amp;apos;Cookie: 请替换为实际浏览器Cookie（如需要）&amp;apos;
    ];

    curl_setopt_array($ch, [
        CURLOPT_URL =&amp;gt; $url,
        CURLOPT_RETURNTRANSFER =&amp;gt; true,
        CURLOPT_SSL_VERIFYPEER =&amp;gt; false,
        CURLOPT_HTTPHEADER =&amp;gt; $headers,
        CURLOPT_FOLLOWLOCATION =&amp;gt; true,
        CURLOPT_ENCODING =&amp;gt; &amp;apos;gzip, deflate&amp;apos;  // 处理压缩响应
    ]);

    $html = curl_exec($ch);
    curl_close($ch);

    // 调试：保存HTML用于分析
    // file_put_contents(&amp;apos;debug.html&amp;apos;, $html);

    // 方案一：从JSON-LD结构化数据提取（微信部分文章适用）
    preg_match(&amp;apos;/&amp;lt;script type=&amp;quot;application\/ld\+json&amp;quot;&amp;gt;(.*?)&amp;lt;\/script&amp;gt;/is&amp;apos;, $html, $jsonMatches);
    if (!empty($jsonMatches[1])) {
        $jsonData = json_decode($jsonMatches[1], true);
        if (isset($jsonData[&amp;apos;name&amp;apos;])) {
            return html_entity_decode($jsonData[&amp;apos;name&amp;apos;], ENT_QUOTES);
        }
    }

    // 方案二：从&amp;lt;meta&amp;gt;标签提取（需处理转义字符）
    preg_match(&amp;apos;/&amp;lt;meta\s+property=&amp;quot;og:title&amp;quot;\s+content=&amp;quot;([^&amp;quot;]+)/i&amp;apos;, $html, $titleMatches);
    $title = $titleMatches[1] ?? null;

    // 方案三：从&amp;lt;title&amp;gt;标签提取（兼容性更强）
    if (empty($title)) {
        preg_match(&amp;apos;/&amp;lt;title&amp;gt;(.*?)&amp;lt;\/title&amp;gt;/i&amp;apos;, $html, $titleTagMatches);
        $title = $titleTagMatches[1] ?? &amp;apos;未找到标题&amp;apos;;
    }

    return html_entity_decode($title, ENT_QUOTES);
}

// 测试URL
$url = &amp;apos;https://mp.weixin.qq.com/s/2h_Z_mwRrigGAwmc7yewKg&amp;apos;;
$title = extractWechatTitle($url);
echo &amp;quot;提取到的标题：\n&amp;quot; . $title;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;代码关键改进点&quot;&gt;&lt;a href=&quot;#代码关键改进点&quot; class=&quot;headerlink&quot; title=&quot;代码关键改进点&quot;&gt;&lt;/a&gt;代码关键改进点&lt;/h4&gt;&lt;h5 id=&quot;1、请求头深度伪装&quot;&gt;&lt;a href=&quot;#1、请求头深度伪装&quot; class=&quot;headerlink&quot; title=&quot;1、请求头深度伪装&quot;&gt;&lt;/a&gt;1、请求头深度伪装&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用 移动端User-Agent（如iPhone Safari）绕过微信的PC端反爬检测&lt;/li&gt;
&lt;li&gt;添加完整的Accept和Accept-Language头模拟真实浏览器环境&lt;/li&gt;
&lt;li&gt;支持Cookie注入（部分文章需要验证登录态）&lt;h5 id=&quot;2、多层级标题提取策略&quot;&gt;&lt;a href=&quot;#2、多层级标题提取策略&quot; class=&quot;headerlink&quot; title=&quot;2、多层级标题提取策略&quot;&gt;&lt;/a&gt;2、多层级标题提取策略&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;优先解析JSON-LD结构化数据（微信文章可能在此隐藏真实标题）&lt;/li&gt;
&lt;li&gt;备用方案：依次尝试og:title元标签和&lt;title&gt;标签&lt;/title&gt;&lt;/li&gt;
&lt;li&gt;自动处理HTML实体转义（如&amp;amp;转回&amp;amp;）&lt;h5 id=&quot;3、调试辅助&quot;&gt;&lt;a href=&quot;#3、调试辅助&quot; class=&quot;headerlink&quot; title=&quot;3、调试辅助&quot;&gt;&lt;/a&gt;3、调试辅助&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;可取消注释file_put_contents保存原始HTML分析页面结构变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;高频问题解决方案&quot;&gt;&lt;a href=&quot;#高频问题解决方案&quot; class=&quot;headerlink&quot; title=&quot;高频问题解决方案&quot;&gt;&lt;/a&gt;高频问题解决方案&lt;/h4&gt;&lt;h5 id=&quot;1、返回“请在微信客户端打开”&quot;&gt;&lt;a href=&quot;#1、返回“请在微信客户端打开”&quot; class=&quot;headerlink&quot; title=&quot;1、返回“请在微信客户端打开”&quot;&gt;&lt;/a&gt;1、返回“请在微信客户端打开”&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;检查User-Agent是否为移动端格式&lt;/li&gt;
&lt;li&gt;添加随机延迟（如sleep(rand(1,5))）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;2、提取到空白标题&quot;&gt;&lt;a href=&quot;#2、提取到空白标题&quot; class=&quot;headerlink&quot; title=&quot;2、提取到空白标题&quot;&gt;&lt;/a&gt;2、提取到空白标题&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;检查Cookie是否有效（需手动从浏览器复制）&lt;/li&gt;
&lt;li&gt;更新正则表达式匹配规则&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;3、请求超时&quot;&gt;&lt;a href=&quot;#3、请求超时&quot; class=&quot;headerlink&quot; title=&quot;3、请求超时&quot;&gt;&lt;/a&gt;3、请求超时&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;设置CURLOPT_TIMEOUT为30秒&lt;/li&gt;
&lt;li&gt;使用代理服务器（配置CURLOPT_PROXY）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：如需进一步优化，可结合 XPath解析器（如DOMDocument）替代正则表达式提升稳定性，或集成 IP代理池 规避访问限制。&lt;/p&gt;
&lt;h3 id=&quot;DeepSeek的建议V2——标题-封面图片&quot;&gt;&lt;a href=&quot;#DeepSeek的建议V2——标题-封面图片&quot; class=&quot;headerlink&quot; title=&quot;DeepSeek的建议V2——标题+封面图片&quot;&gt;&lt;/a&gt;DeepSeek的建议V2——标题+封面图片&lt;/h3&gt;&lt;p&gt;以下是整合标题与封面图提取的 完整PHP代码，基于微信公开文章的页面结构优化，并增加对图片URL的特殊处理（如解码&amp;amp;转义字符）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
function extractWechatInfo($url) {
    $ch = curl_init();

    // 模拟移动端浏览器请求头（关键）
    $headers = [
        &amp;apos;User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1&amp;apos;,
        &amp;apos;Referer: https://mp.weixin.qq.com/&amp;apos;,
        &amp;apos;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&amp;apos;,
        &amp;apos;Accept-Language: zh-CN,zh;q=0.9&amp;apos;,
        &amp;apos;Accept-Encoding: gzip, deflate, br&amp;apos;
    ];

    curl_setopt_array($ch, [
        CURLOPT_URL =&amp;gt; $url,
        CURLOPT_RETURNTRANSFER =&amp;gt; true,
        CURLOPT_SSL_VERIFYPEER =&amp;gt; false,
        CURLOPT_HTTPHEADER =&amp;gt; $headers,
        CURLOPT_FOLLOWLOCATION =&amp;gt; true,
        CURLOPT_ENCODING =&amp;gt; &amp;apos;gzip, deflate&amp;apos;
    ]);

    $html = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);

    // 调试：保存HTML（排查反爬问题）
    // file_put_contents(&amp;apos;wechat_page.html&amp;apos;, $html);

    $result = [&amp;apos;title&amp;apos; =&amp;gt; &amp;apos;&amp;apos;, &amp;apos;cover&amp;apos; =&amp;gt; &amp;apos;&amp;apos;];

    // 提取标题 ---------------------------------------------------
    // 方案1：从JSON-LD结构化数据提取
    preg_match(&amp;apos;/&amp;lt;script type=&amp;quot;application\/ld\+json&amp;quot;&amp;gt;(.*?)&amp;lt;\/script&amp;gt;/is&amp;apos;, $html, $jsonMatches);
    if (!empty($jsonMatches[1])) {
        $jsonData = json_decode($jsonMatches[1], true);
        if (isset($jsonData[&amp;apos;name&amp;apos;])) {
            $result[&amp;apos;title&amp;apos;] = html_entity_decode($jsonData[&amp;apos;name&amp;apos;], ENT_QUOTES);
        }
    }

    // 方案2：从&amp;lt;meta&amp;gt;标签提取
    if (empty($result[&amp;apos;title&amp;apos;])) {
        preg_match(&amp;apos;/&amp;lt;meta\s+property=&amp;quot;og:title&amp;quot;\s+content=&amp;quot;([^&amp;quot;]+)/i&amp;apos;, $html, $titleMatches);
        $result[&amp;apos;title&amp;apos;] = $titleMatches[1] ?? &amp;apos;&amp;apos;;
    }

    // 方案3：从&amp;lt;title&amp;gt;标签提取
    if (empty($result[&amp;apos;title&amp;apos;])) {
        preg_match(&amp;apos;/&amp;lt;title&amp;gt;(.*?)&amp;lt;\/title&amp;gt;/i&amp;apos;, $html, $titleTagMatches);
        $result[&amp;apos;title&amp;apos;] = $titleTagMatches[1] ?? &amp;apos;标题未找到&amp;apos;;
    }

    // 提取封面图 -------------------------------------------------
    // 方案1：从Open Graph协议获取
    preg_match(&amp;apos;/&amp;lt;meta\s+property=&amp;quot;og:image&amp;quot;\s+content=&amp;quot;([^&amp;quot;]+)/i&amp;apos;, $html, $imageMatches);
    $coverUrl = $imageMatches[1] ?? &amp;apos;&amp;apos;;

    // 方案2：从JavaScript变量获取（微信特有）
    if (empty($coverUrl)) {
        preg_match(&amp;apos;/var msg_cdn_url\s*=\s*[&amp;quot;\&amp;apos;](.*?)[&amp;quot;\&amp;apos;]/i&amp;apos;, $html, $jsMatches);
        $coverUrl = $jsMatches[1] ?? &amp;apos;&amp;apos;;
    }

    // 处理微信图片URL转义问题（如 &amp;amp;amp; 转 &amp;amp;）
    $coverUrl = str_replace([&amp;apos;&amp;amp;amp;&amp;apos;, &amp;apos;\u0026&amp;apos;], &amp;apos;&amp;amp;&amp;apos;, $coverUrl);
    $result[&amp;apos;cover&amp;apos;] = $coverUrl;

    return $result;
}

// 使用示例
$url = &amp;apos;https://mp.weixin.qq.com/s/2h_Z_mwRrigGAwmc7yewKg&amp;apos;;
$data = extractWechatInfo($url);

echo &amp;quot;文章标题：\n&amp;quot; . $data[&amp;apos;title&amp;apos;] . &amp;quot;\n\n&amp;quot;;
echo &amp;quot;封面图地址：\n&amp;quot; . ($data[&amp;apos;cover&amp;apos;] ?: &amp;apos;未找到封面图&amp;apos;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;代码增强特性说明&quot;&gt;&lt;a href=&quot;#代码增强特性说明&quot; class=&quot;headerlink&quot; title=&quot;代码增强特性说明&quot;&gt;&lt;/a&gt;代码增强特性说明&lt;/h4&gt;&lt;h5 id=&quot;封面图双保险提取策略&quot;&gt;&lt;a href=&quot;#封面图双保险提取策略&quot; class=&quot;headerlink&quot; title=&quot;封面图双保险提取策略&quot;&gt;&lt;/a&gt;封面图双保险提取策略&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;第一优先级：解析标准的og:image元标签&lt;/li&gt;
&lt;li&gt;第二优先级：捕获微信特有的msg_cdn_url变量（常用于未登录场景）&lt;/li&gt;
&lt;li&gt;特殊处理：修复微信返回的图片URL中转义字符问题（如&amp;amp;转义符）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;移动端环境模拟&quot;&gt;&lt;a href=&quot;#移动端环境模拟&quot; class=&quot;headerlink&quot; title=&quot;移动端环境模拟&quot;&gt;&lt;/a&gt;移动端环境模拟&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用 iOS Safari 的User-Agent绕过PC端反爬检测&lt;/li&gt;
&lt;li&gt;添加完整的Accept-*头模拟真实用户访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;调试支持&quot;&gt;&lt;a href=&quot;#调试支持&quot; class=&quot;headerlink&quot; title=&quot;调试支持&quot;&gt;&lt;/a&gt;调试支持&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;可取消注释file_put_contents保存原始HTML分析反爬拦截情况&lt;/li&gt;
&lt;li&gt;自动输出HTTP状态码辅助诊断网络问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;高频问题处理指南&quot;&gt;&lt;a href=&quot;#高频问题处理指南&quot; class=&quot;headerlink&quot; title=&quot;高频问题处理指南&quot;&gt;&lt;/a&gt;高频问题处理指南&lt;/h4&gt;&lt;h5 id=&quot;返回默认微信Logo封面&quot;&gt;&lt;a href=&quot;#返回默认微信Logo封面&quot; class=&quot;headerlink&quot; title=&quot;返回默认微信Logo封面&quot;&gt;&lt;/a&gt;返回默认微信Logo封面&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;检查User-Agent是否为最新移动端版本&lt;/li&gt;
&lt;li&gt;尝试添加有效Cookie（需手动抓取）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;封面图URL无法访问&quot;&gt;&lt;a href=&quot;#封面图URL无法访问&quot; class=&quot;headerlink&quot; title=&quot;封面图URL无法访问&quot;&gt;&lt;/a&gt;封面图URL无法访问&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在代码中添加URL解码：urldecode($coverUrl)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;HTTP-403-404错误&quot;&gt;&lt;a href=&quot;#HTTP-403-404错误&quot; class=&quot;headerlink&quot; title=&quot;HTTP 403/404错误&quot;&gt;&lt;/a&gt;HTTP 403/404错误&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用代理IP&lt;/li&gt;
&lt;li&gt;降低请求频率（如添加sleep(1)）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;提取内容为空&quot;&gt;&lt;a href=&quot;#提取内容为空&quot; class=&quot;headerlink&quot; title=&quot;提取内容为空&quot;&gt;&lt;/a&gt;提取内容为空&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;检查wechat_page.html是否包含“请在微信客户端打开”提示，调整请求头策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：如需处理 登录态限制，可通过浏览器开发者工具复制登录后的Cookie填入$headers数组（需定期更新）。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;1、对问题：需要更敏感，及时发现问题，及时解决问题。&lt;/p&gt;
&lt;p&gt;同时把不同项目用到相同算法的部分都同同时更新到新的有效的算法。&lt;/p&gt;
&lt;p&gt;2、处理问题时，需要多用AI大模型的支持。&lt;/p&gt;
&lt;p&gt;简单的问题自己想好解决方案后，可以与大模型给到方案对比，选个更好的用；&lt;br&gt;复杂困难的问题，可以让大模型给提供具体的建议。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原来写的算法【对微信公众号文章的链接直接提取标题与封面图片URL】突然失效了，就在今天2025年03月13日。&lt;br&gt;目前在我们产品中使用的场景还需要继续支持，需要修复。&lt;/p&gt;
&lt;p&gt;第一反应：在我系统中算法未更改的情况下，微信公众号文章的html页面结构有变化，导致原来
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="API" scheme="http://isunman.com/tags/api/"/>
    
      <category term="HTTP" scheme="http://isunman.com/tags/http/"/>
    
      <category term="大模型" scheme="http://isunman.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="爬虫" scheme="http://isunman.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo和Github搭建博客（4）：近几年更新汇总</title>
    <link href="http://isunman.com/2025/03/09/blog-by-hexo-github-step4-lastupdate/"/>
    <id>http://isunman.com/2025/03/09/blog-by-hexo-github-step4-lastupdate/</id>
    <published>2025-03-08T21:20:00.000Z</published>
    <updated>2025-03-08T21:24:58.847Z</updated>
    
    <content type="html">&lt;p&gt;用Hexo和Github搭建博客（4）：近几年更新汇总&lt;/p&gt;
&lt;h3 id=&quot;一、nodejs新版本&quot;&gt;&lt;a href=&quot;#一、nodejs新版本&quot; class=&quot;headerlink&quot; title=&quot;一、nodejs新版本&quot;&gt;&lt;/a&gt;一、nodejs新版本&lt;/h3&gt;&lt;p&gt;已经重新安装&lt;/p&gt;
&lt;p&gt;原来版本：node-v5.7.0-x64&lt;/p&gt;
&lt;p&gt;新安装版本：node-v12.22.12-x86&lt;/p&gt;
&lt;p&gt;因为是在Win7系统中，所以还不能安装更加新的版本；否则，可能运行不了。&lt;/p&gt;
&lt;p&gt;安装后重新配置node与npm的关键目录，与设置环境变量。&lt;/p&gt;
&lt;h3 id=&quot;二、Hexo的远程部署&quot;&gt;&lt;a href=&quot;#二、Hexo的远程部署&quot; class=&quot;headerlink&quot; title=&quot;二、Hexo的远程部署&quot;&gt;&lt;/a&gt;二、Hexo的远程部署&lt;/h3&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo d的错误remote: Invalid username or password.&lt;br&gt;fatal: Authentication failed for&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改Hexo 根目录下的_config.yml文件&lt;/p&gt;
&lt;p&gt;在文件的最后，代码修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:

    type: git

    repo: git@github.com:isunman/isunman.github.com.git 

    branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要改动是repo这一行。&lt;/p&gt;
&lt;h5 id=&quot;HTTPS-切换为-SSH-协议&quot;&gt;&lt;a href=&quot;#HTTPS-切换为-SSH-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTPS 切换为 SSH 协议&quot;&gt;&lt;/a&gt;HTTPS 切换为 SSH 协议&lt;/h5&gt;&lt;p&gt;既能解决HTTPS访问网络不稳定的问题，也能解决认证容易因密码变更或 2FA 导致失败等问题。&lt;/p&gt;
&lt;p&gt;关于SSH怎么使用，SSH keys怎么生成等问题可以查看官方说明：&lt;br&gt;&lt;a href=&quot;https://docs.github.com/en/authentication/connecting-to-github-with-ssh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.github.com/en/authentication/connecting-to-github-with-ssh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;已亲测可用。&lt;/p&gt;
&lt;h3 id=&quot;三、GitHub的分支master与main区别&quot;&gt;&lt;a href=&quot;#三、GitHub的分支master与main区别&quot; class=&quot;headerlink&quot; title=&quot;三、GitHub的分支master与main区别&quot;&gt;&lt;/a&gt;三、GitHub的分支master与main区别&lt;/h3&gt;&lt;p&gt;GitHub 中的 master 和 main 分支本质上是同一概念的不同命名，主要区别源于命名习惯的调整和包容性考量。以下是两者的核心差异和关联：&lt;/p&gt;
&lt;h5 id=&quot;1、名称差异与历史背景&quot;&gt;&lt;a href=&quot;#1、名称差异与历史背景&quot; class=&quot;headerlink&quot; title=&quot;1、名称差异与历史背景&quot;&gt;&lt;/a&gt;1、名称差异与历史背景&lt;/h5&gt;&lt;p&gt;master：&lt;br&gt;这是 Git 早期默认的主分支名称，广泛用于旧项目中。其名称源自版本控制系统的传统术语，但因其与奴隶制（”master-slave”）的潜在关联，逐渐被认为不够包容。&lt;/p&gt;
&lt;p&gt;main：&lt;br&gt;自 2020 年 10 月起，GitHub 将新仓库的默认主分支名称改为 main，以推动更具包容性的术语。其他平台（如 GitLab）也逐步采用这一变更。&lt;/p&gt;
&lt;h5 id=&quot;2、功能与用途&quot;&gt;&lt;a href=&quot;#2、功能与用途&quot; class=&quot;headerlink&quot; title=&quot;2、功能与用途&quot;&gt;&lt;/a&gt;2、功能与用途&lt;/h5&gt;&lt;p&gt;功能一致性：&lt;br&gt;无论是 master 还是 main，其功能完全相同，均为项目的主分支，用于存放经过测试的稳定代码，并作为其他开发分支（如 develop、feature）的合并目标。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;master：常见于旧项目或未主动更名的仓库。&lt;/p&gt;
&lt;p&gt;main：新项目的默认选择，尤其适用于注重包容性的团队或组织。&lt;/p&gt;
&lt;h5 id=&quot;3、底层原理&quot;&gt;&lt;a href=&quot;#3、底层原理&quot; class=&quot;headerlink&quot; title=&quot;3、底层原理&quot;&gt;&lt;/a&gt;3、底层原理&lt;/h5&gt;&lt;p&gt;分支本质：&lt;br&gt;在 Git 中，分支仅是指向某个提交的指针，名称变更不影响其底层逻辑。无论是 master 还是 main，均通过相同机制管理代码提交、合并与推送514。&lt;/p&gt;
&lt;p&gt;默认分支配置：&lt;/p&gt;
&lt;p&gt;Git 允许通过 .git/config 或命令（如 git symbolic-ref）自定义默认分支名称。&lt;/p&gt;
&lt;p&gt;GitHub 提供仓库设置界面，支持修改默认分支。&lt;/p&gt;
&lt;h5 id=&quot;4、操作差异&quot;&gt;&lt;a href=&quot;#4、操作差异&quot; class=&quot;headerlink&quot; title=&quot;4、操作差异&quot;&gt;&lt;/a&gt;4、操作差异&lt;/h5&gt;&lt;p&gt;重命名分支：&lt;br&gt;若需将旧项目的 master 改为 main，可执行以下步骤：&lt;/p&gt;
&lt;p&gt;切换到本地 master：git checkout master&lt;/p&gt;
&lt;p&gt;重命名分支：git branch -m main&lt;/p&gt;
&lt;p&gt;推送新分支：git push -u origin main&lt;/p&gt;
&lt;p&gt;删除远程旧分支（可选）：git push origin –delete master&lt;/p&gt;
&lt;p&gt;在 GitHub 仓库设置中更新默认分支513。&lt;/p&gt;
&lt;p&gt;兼容性注意：&lt;br&gt;若协作项目仍使用 master，需确保本地与远程分支名称一致，避免推送冲突。&lt;/p&gt;
&lt;h5 id=&quot;5、社区与平台支持&quot;&gt;&lt;a href=&quot;#5、社区与平台支持&quot; class=&quot;headerlink&quot; title=&quot;5、社区与平台支持&quot;&gt;&lt;/a&gt;5、社区与平台支持&lt;/h5&gt;&lt;p&gt;GitHub 的默认规则：&lt;/p&gt;
&lt;p&gt;2020 年 10 月后创建的仓库默认使用 main，旧仓库不受影响。&lt;/p&gt;
&lt;p&gt;用户可手动修改默认分支名称，但需同步更新 CI/CD 等依赖分支名的配置813。&lt;/p&gt;
&lt;p&gt;其他平台：&lt;br&gt;GitLab 等平台也支持类似调整，但具体实现可能略有差异。&lt;/p&gt;
&lt;h5 id=&quot;6、总结&quot;&gt;&lt;a href=&quot;#6、总结&quot; class=&quot;headerlink&quot; title=&quot;6、总结&quot;&gt;&lt;/a&gt;6、总结&lt;/h5&gt;&lt;p&gt;若需统一分支命名或启动新项目，推荐使用 main 以符合现代实践。对于既有项目，可根据团队需求决定是否调整&lt;/p&gt;
&lt;h3 id=&quot;四、更新博客源文件source的错误&quot;&gt;&lt;a href=&quot;#四、更新博客源文件source的错误&quot; class=&quot;headerlink&quot; title=&quot;四、更新博客源文件source的错误&quot;&gt;&lt;/a&gt;四、更新博客源文件source的错误&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行后提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fatal: unable to access
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&amp;#39;https://github.com/xxx/aaaa.git/&amp;#39;: Empty reply from server&lt;/code&gt;，这通常表示 网络通信异常 或 Git 服务器未响应。以下是分步排查和解决方案：&lt;/p&gt;
&lt;h5 id=&quot;1、检查网络连通性&quot;&gt;&lt;a href=&quot;#1、检查网络连通性&quot; class=&quot;headerlink&quot; title=&quot;1、检查网络连通性&quot;&gt;&lt;/a&gt;1、检查网络连通性&lt;/h5&gt;&lt;p&gt;测试 GitHub 访问：若返回 HTTP/2 200，说明网络正常；若超时或无响应，可能是网络被阻断。&lt;/p&gt;
&lt;p&gt;排查代理或防火墙：如果使用代理，确保 Git 配置了正确的代理；临时关闭 VPN 或防火墙测试。&lt;/p&gt;
&lt;h5 id=&quot;2、验证仓库-URL-是否正确&quot;&gt;&lt;a href=&quot;#2、验证仓库-URL-是否正确&quot; class=&quot;headerlink&quot; title=&quot;2、验证仓库 URL 是否正确&quot;&gt;&lt;/a&gt;2、验证仓库 URL 是否正确&lt;/h5&gt;&lt;p&gt;检查远程仓库地址是否存在拼写错误；若 URL 错误，修正后重试。&lt;/p&gt;
&lt;h5 id=&quot;3、尝试切换协议（HTTPS-—-gt-SSH）&quot;&gt;&lt;a href=&quot;#3、尝试切换协议（HTTPS-—-gt-SSH）&quot; class=&quot;headerlink&quot; title=&quot;3、尝试切换协议（HTTPS —-&amp;gt; SSH）&quot;&gt;&lt;/a&gt;3、尝试切换协议（HTTPS —-&amp;gt; SSH）&lt;/h5&gt;&lt;p&gt;改用 SSH 协议（避免 HTTPS 端口或代理问题）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote set-url origin git@github.com:用户名/仓库名.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若 SSH 失败，检查密钥配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -T git@github.com  # 验证 SSH 连接
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(实际测试时，到这一步成功了）&lt;/p&gt;
&lt;h5 id=&quot;4-清除-Git-缓存和凭据&quot;&gt;&lt;a href=&quot;#4-清除-Git-缓存和凭据&quot; class=&quot;headerlink&quot; title=&quot;4. 清除 Git 缓存和凭据&quot;&gt;&lt;/a&gt;4. 清除 Git 缓存和凭据&lt;/h5&gt;&lt;h5 id=&quot;5-检查-GitHub-服务状态&quot;&gt;&lt;a href=&quot;#5-检查-GitHub-服务状态&quot; class=&quot;headerlink&quot; title=&quot;5. 检查 GitHub 服务状态&quot;&gt;&lt;/a&gt;5. 检查 GitHub 服务状态&lt;/h5&gt;&lt;h5 id=&quot;6-调整-Git-配置（临时测试）&quot;&gt;&lt;a href=&quot;#6-调整-Git-配置（临时测试）&quot; class=&quot;headerlink&quot; title=&quot;6.  调整 Git 配置（临时测试）&quot;&gt;&lt;/a&gt;6.  调整 Git 配置（临时测试）&lt;/h5&gt;&lt;h5 id=&quot;7-检查本地-Git-版本&quot;&gt;&lt;a href=&quot;#7-检查本地-Git-版本&quot; class=&quot;headerlink&quot; title=&quot;7. 检查本地 Git 版本&quot;&gt;&lt;/a&gt;7. 检查本地 Git 版本&lt;/h5&gt;&lt;h5 id=&quot;8-检查仓库权限和认证方式&quot;&gt;&lt;a href=&quot;#8-检查仓库权限和认证方式&quot; class=&quot;headerlink&quot; title=&quot;8.  检查仓库权限和认证方式&quot;&gt;&lt;/a&gt;8.  检查仓库权限和认证方式&lt;/h5&gt;&lt;h5 id=&quot;9-使用调试模式定位问题&quot;&gt;&lt;a href=&quot;#9-使用调试模式定位问题&quot; class=&quot;headerlink&quot; title=&quot;9. 使用调试模式定位问题&quot;&gt;&lt;/a&gt;9. 使用调试模式定位问题&lt;/h5&gt;&lt;h5 id=&quot;10、-终极方案：重置远程仓库&quot;&gt;&lt;a href=&quot;#10、-终极方案：重置远程仓库&quot; class=&quot;headerlink&quot; title=&quot;10、 终极方案：重置远程仓库&quot;&gt;&lt;/a&gt;10、 终极方案：重置远程仓库&lt;/h5&gt;&lt;p&gt;如果仓库可重建，尝试重新初始化并推送：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf .git
git init
git remote add origin https://github.com/用户名/仓库名.git
git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方案暂时不用。&lt;/p&gt;
&lt;h3 id=&quot;五、以上总结&quot;&gt;&lt;a href=&quot;#五、以上总结&quot; class=&quot;headerlink&quot; title=&quot;五、以上总结&quot;&gt;&lt;/a&gt;五、以上总结&lt;/h3&gt;&lt;p&gt;用像Hexo做分享创作的问题，需要解决后，可以流畅操作。&lt;/p&gt;
&lt;p&gt;现在已经进入到了AI大模型时代，需要尽快学习，然后思考接入使用，总结表达分享自己的思考结果。&lt;/p&gt;
&lt;p&gt;————————————&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;http://isunman.com/2016/02/25/blog-by-hexo-github-step1/&quot; title=&quot;用Hexo和Github搭建博客（1）：安装环境&quot;&gt;用Hexo和Github搭建博客（1）：安装环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://isunman.com/2016/02/25/blog-by-hexo-github-step2/&quot; title=&quot;用Hexo和Github搭建博客（2）：部署到Github&quot;&gt;用Hexo和Github搭建博客（2）：部署到Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://isunman.com/2016/02/26/blog-by-hexo-github-step3/&quot; title=&quot;用Hexo和github搭建博客（3）：Hexo介绍&quot;&gt;用Hexo和github搭建博客（3）：Hexo介绍&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用Hexo和Github搭建博客（4）：近几年更新汇总&lt;/p&gt;
&lt;h3 id=&quot;一、nodejs新版本&quot;&gt;&lt;a href=&quot;#一、nodejs新版本&quot; class=&quot;headerlink&quot; title=&quot;一、nodejs新版本&quot;&gt;&lt;/a&gt;一、nodejs新版本&lt;/h3&gt;&lt;p
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="http://isunman.com/tags/hexo/"/>
    
      <category term="github" scheme="http://isunman.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>关于AI与大模型的几点想法</title>
    <link href="http://isunman.com/2025/03/08/A-few-thoughts-on-AI-and-large-models/"/>
    <id>http://isunman.com/2025/03/08/A-few-thoughts-on-AI-and-large-models/</id>
    <published>2025-03-08T15:23:00.000Z</published>
    <updated>2025-03-08T17:33:11.644Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、模型不是产品&quot;&gt;&lt;a href=&quot;#一、模型不是产品&quot; class=&quot;headerlink&quot; title=&quot;一、模型不是产品&quot;&gt;&lt;/a&gt;一、模型不是产品&lt;/h3&gt;&lt;p&gt;AI大模型会折叠掉大量按照过去思路设计的产品，但也会催生一个全新的产品簇。从对旧世界产品的破坏来讲，模型即产品；从创建新产品世界来讲模型不是产品。&lt;/p&gt;
&lt;h5 id=&quot;1、人的角色和价值&quot;&gt;&lt;a href=&quot;#1、人的角色和价值&quot; class=&quot;headerlink&quot; title=&quot;1、人的角色和价值&quot;&gt;&lt;/a&gt;1、人的角色和价值&lt;/h5&gt;&lt;p&gt;知识的螺旋-组织是知识的载体，知识是组织的本质&lt;br&gt;&lt;img src=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2025%2F0308%2Feae363b4j00sssikj006pd200u000h8g00fe008u.jpg&amp;amp;thumbnail=660x2147483647&amp;amp;quality=80&amp;amp;type=jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但在新模式下，AI驱动的组织既承载知识也创造知识。&lt;/p&gt;
&lt;p&gt;AI不会创造所有知识，真正的新知识创建还有人类的角色在。&lt;/p&gt;
&lt;p&gt;人与智能组织的协作边界是需要复杂定义的，并且每个公司的知识系统不一样，偏好不一样，模型自身不能包含所有公司的偏好和特征。&lt;/p&gt;
&lt;h5 id=&quot;2、数字与非数字的边界&quot;&gt;&lt;a href=&quot;#2、数字与非数字的边界&quot; class=&quot;headerlink&quot; title=&quot;2、数字与非数字的边界&quot;&gt;&lt;/a&gt;2、数字与非数字的边界&lt;/h5&gt;&lt;p&gt;人和AI的权重是动态的&lt;/p&gt;
&lt;p&gt;在知识创造过程中，人可以调度这四个维度上信息进行知识创造，AI也可以。因为这里面很多东西是私有的，所以私有知识应运而生。&lt;/p&gt;
&lt;p&gt;边界之外可以归于模型，这是归一化的，边界以里归于自身，这是差异化的。也就是说如果企业不创造差异化的知识，那基本没有存在价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那其实就是模型的归模型（通用知识和通用智能），应用的归应用（任务导向的多角色联动，权限，物理世界的接入，人机协同边界的处理等）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、模型的产品化&quot;&gt;&lt;a href=&quot;#二、模型的产品化&quot; class=&quot;headerlink&quot; title=&quot;二、模型的产品化&quot;&gt;&lt;/a&gt;二、模型的产品化&lt;/h3&gt;&lt;p&gt;“模型作为产品”的两个典型例子：OpenAI 的 Deep Research 和 Claude Sonnet 3.7。　&lt;/p&gt;
&lt;p&gt;Anthropic 一直在更清晰地阐述他们的愿景。他们提出了一个有争议但在我看来正确的 Agent 模型定义。　&lt;/p&gt;
&lt;p&gt;类似于 Deep Search，Agent 必须在内部执行目标任务：它们”动态指导自己的过程和工具使用，控制完成任务的方式”。&lt;/p&gt;
&lt;p&gt;目前大多数 Agent 初创公司构建的不是真正的 Agent，而是工作流，即”通过预定义的代码路径编排 LLM 和工具的系统”。工作流在某些垂直领域仍可能创造价值。&lt;/p&gt;
&lt;p&gt;针对做C端产品来说，用户并不关心是Agent还是App，他们只关心问题是否被解决。技术路线的选择应该基于用户体验而非技术理想，&lt;strong&gt;最好的产品是让用户感受不到技术的存在&lt;/strong&gt;。用户只需要提供需求场景和订单即可。技术进步的目标是创造实际价值，无论是Agent还是App，都需要解决真实问题。&lt;/p&gt;
&lt;p&gt;我们的产品本来就在解决我们想要解决的问题，只是在没有AI大模型的支持时，需要找其他的方案；但是既然有了AI大模型的加持，我们的解决方案可以更酷更靓更高效更有趣更好玩。&lt;/p&gt;
&lt;p&gt;同时，除了产品本身好玩以外，我们开发产品的工具与工作流程也会因为AI大模型的加持而彻底改变。不仅仅是提高效率，更可以做之前做不到的事，而且是以更小的成本。在这里又一次体现了“投入产出比”的计算意识的重要性。&lt;/p&gt;
&lt;p&gt;这一切的关键，是我自己首先立即把大模型的能力给用起来，用到开发产品，用到产品本身。能用多很就用多很，大模型的能力像无底洞一样，这才用到哪。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;应无所住，而生其心。&lt;br&gt;真正的创造需要一颗鲜活的心。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源参考：&lt;a href=&quot;https://mp.weixin.qq.com/s/5JzhJIUY3vpz4RGyobI7Ag&quot; title=&quot;大模型的未来，是 Agent 还是 App？&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mp.weixin.qq.com/s/5JzhJIUY3vpz4RGyobI7Ag&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、模型不是产品&quot;&gt;&lt;a href=&quot;#一、模型不是产品&quot; class=&quot;headerlink&quot; title=&quot;一、模型不是产品&quot;&gt;&lt;/a&gt;一、模型不是产品&lt;/h3&gt;&lt;p&gt;AI大模型会折叠掉大量按照过去思路设计的产品，但也会催生一个全新的产品簇。从对旧世界产品的破
    
    </summary>
    
      <category term="大模型" scheme="http://isunman.com/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="AI" scheme="http://isunman.com/tags/ai/"/>
    
      <category term="大模型" scheme="http://isunman.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>全面剖析 PHP-FPM+Nginx 通信原理</title>
    <link href="http://isunman.com/2023/08/21/comprehensive-analysis-of-PHP-FPM+Nginx-communication-principle/"/>
    <id>http://isunman.com/2023/08/21/comprehensive-analysis-of-PHP-FPM+Nginx-communication-principle/</id>
    <published>2023-08-21T06:50:00.000Z</published>
    <updated>2023-08-21T07:04:01.301Z</updated>
    
    <content type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;用了这么久了PHP+Nginx了，你了解他们之间的通信原理吗？这一次做一回真正的PHPer（在上一篇文章里边已经全面介绍了CGI、FastCGI、PHP-FPM，所以本文对于这些概念不再介绍的那么详细）&lt;/p&gt;
&lt;h2 id=&quot;PHP-FPM&quot;&gt;&lt;a href=&quot;#PHP-FPM&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM&quot;&gt;&lt;/a&gt;PHP-FPM&lt;/h2&gt;&lt;p&gt;PHP-FPM的全称是PHP FastCGI Process Manager，PHP-FPM是FastCGI的实现，并提供了进程管理的功能。FastCGI进程包含master进程和worker进程两种进程。master进程只有一个，负责监听端口，接收Nginx的请求，而worker进程则一般有多个(可配置)，每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方。&lt;/p&gt;
&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;p&gt;Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。这里介绍一下什么是正向代理和反向代理，这个对于我们理解Nginx很重要&lt;/p&gt;
&lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h2&gt;&lt;p&gt;我们那访问国外的网站为例，比如访问Google、Facebook。我们需要借助vpn才能访问，我们借助vpn访问国外的网站，其实就是个正向代理的过程，上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-264693523af2543b568ed9aa7c7d97ec_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;vpn对于用户来说，是可以感知到的（因为用户需要配置连接），vpn对于google服务器来说，是不可感知的(google服务器只知道有http请求过来)。所以，对于用户来说可以感知到，而对于服务器来说感知不到的服务器，就是正向代理服务器（vpn）&lt;/p&gt;
&lt;h2 id=&quot;反向代理&quot;&gt;&lt;a href=&quot;#反向代理&quot; class=&quot;headerlink&quot; title=&quot;反向代理&quot;&gt;&lt;/a&gt;反向代理&lt;/h2&gt;&lt;p&gt;拿Nginx作为反向代理服务器实现负载均衡来举例，假设此时我们访问百度，看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-a9736998fd30679e11150296ada745d7_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当用户访问百度时，所有的请求会到达一个反向代理服务器，这个反向代理服务器会将请求分发给后边的某一台服务器去处理。此时，这个代理服务器其实对用户来说是不可感知的，用户感知到的是百度的服务器给自己返回了结果，并不知道代理服务器的存在。也就是说，对于用户来说不可感知，对于服务器来说是可以感知的，就叫反向代理服务器（Nginx）&lt;/p&gt;
&lt;h2 id=&quot;PHP-FPM-Nginx通信&quot;&gt;&lt;a href=&quot;#PHP-FPM-Nginx通信&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM+Nginx通信&quot;&gt;&lt;/a&gt;PHP-FPM+Nginx通信&lt;/h2&gt;&lt;p&gt;FastCGI致力于减少Web服务器与CGI程序之间互动的开销，从而使服务器可以同时处理更多的Web请求。与CGI这种为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。&lt;strong&gt;这些进程由FastCGI进程管理器管理，而不是web服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过图来理解PHP-FPM和Nginx的通信&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-5b4221240c64823f21975422586e91dc_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（1）当Nginx收到http请求（动态请求），它会初始化FastCGI环境。（如果是Apache服务器，则初始化modefastcgi模块、如果是Nginx服务器则初始化ngxhttp_fastcgi_module）&lt;/p&gt;
&lt;p&gt;（2）我们在配置nginx解析php请求时，一般会有这样一行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fastcgi_pass 127.0.0.1:9000;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者长这样：&lt;br&gt;    fastcgi_pass unix:/tmp/php-cgi.sock;&lt;/p&gt;
&lt;p&gt;它其实是Nginx和PHP-FPM一个通信载体（或者说通信方式），目的是为了让Nginx知道，收到动态请求之后该往哪儿发。（关于这两种配置的区别，后边会专门介绍）&lt;/p&gt;
&lt;p&gt;（3）Nginx将请求采用socket的方式转给FastCGI主进程&lt;/p&gt;
&lt;p&gt;（4）FastCGI主进程选择一个空闲的worker进程连接，然后Nginx将CGI环境变量和标准输入发送该worker进程（php-cgi）&lt;/p&gt;
&lt;p&gt;（5）worker进程完成处理后将标准输出和错误信息从同一socket连接返回给Nginx&lt;/p&gt;
&lt;p&gt;（6）worker进程关闭连接，等待下一个连接&lt;/p&gt;
&lt;h2 id=&quot;不从配置的角度，再描述一下PHP和Nginx的通信&quot;&gt;&lt;a href=&quot;#不从配置的角度，再描述一下PHP和Nginx的通信&quot; class=&quot;headerlink&quot; title=&quot;不从配置的角度，再描述一下PHP和Nginx的通信&quot;&gt;&lt;/a&gt;不从配置的角度，再描述一下PHP和Nginx的通信&lt;/h2&gt;&lt;p&gt;我们知道Nginx也是有master和worker进程的，worker进程直接处理每一个网络请求&lt;br&gt;其实在Nginx+PHP的架构里边，php可以看做是一个cgi程序的角色，因此出现了php-fpm进程管理器来处理这些php请求。php-fpm和nginx一样，也会监听端口（通过nginx.conf里的配置我们知道，nginx默认监听8080端口，php-fpm默认监听9000端口），并且有master和worker进程，worker负责处理每一个php请求&lt;br&gt;关于fastcgi：fastcgi是一个协议。市面上有多种实现了fastcgi协议的进程管理器，php-fpm就是其中的一种。php-fpm作为一种fastcgi进程管理服务，会监听端口，一般默认监听9000端口，并且是监听本机，也就是只接收来自本机的端口请求&lt;br&gt;关于fastcgi的配置文件，目前fastcgi的配置文件一般放在nginx.conf同级目录下，配置文件形式，一般有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fastcgi.conf和 fastcgi_params。
不同的nginx版本会有不同的配置文件，这两个配置文件有一个非常重要的区别：
fastcgi_parames文件中缺少下列配置：
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以打开fastcgi_params文件加上上述行，也可以在要使用配置的地方动态添加。使得该配置生效&lt;/p&gt;
&lt;p&gt;当需要处理php请求时，nginx的worker进程会将请求移交给php-fpm的worker进程进行处理，也就是最开头所说的nginx调用了php，其实严格得讲是nginx间接调用php（反向代理的方式）&lt;br&gt;我本机配置了能正常解析php程序的nginx配置，介绍一下每一行配置的含义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server{
listen 8080;
index index.php
root /work/html/;
location ~ [^/]\.php(/|$)
{
root /work/html/;
fastcgi_pass 127.0.0.1:9000;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
include fastcgi_params;
}
access_log /work/html/logs/test.log;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个大括号 server{ }：代表一个独立的server&lt;br&gt;listen 8080：代表该server监听8080端口&lt;br&gt;location ~ [^/].php(/|$){ }：代表一个能匹配对应uri的location，用于匹配一类uri，并对所匹配的uri请求做自定义的逻辑、配置。这里的location，匹配了所有带.php的uri请求，例如：&lt;a href=&quot;http://192.168.244.128:8011/test.php/asdasdhttp://192.168.244.128:8011/index.php等&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.244.128:8011/test.php/asdasdhttp://192.168.244.128:8011/index.php等&lt;/a&gt;&lt;br&gt;root /work/html/：请求资源根目录，告诉匹配到该location下的uri到/work/html/文件夹下去寻找同名资源&lt;br&gt;fastcgi_pass 127.0.0.1:9000：这行代码的意思是，将进入到该location内的uri请求看做是cgi程序，并将请求发送到9000端口，交由php-fpm处理(php-fpm配置中会看见它监听了此端口)&lt;br&gt;fastcgiparam SCRIPTFILENAME&lt;/p&gt;
&lt;p&gt;fastcgiscriptname; ：这行配置意思是：动态添加了一行fastcgi配置，配置内容为SCRIPTFILENAME，告知管理进程，cgi脚本名称。由于我的nginx中只有fastcgiparams文件，没有fastcgi.conf文件，所以要使php-fpm知道SCRIPT_FILENAME的具体值，就必须要动态的添加这行配置&lt;/p&gt;
&lt;p&gt;include fastcgi_params; 引入fastcgi配置文件&lt;/p&gt;
&lt;h3 id=&quot;fastcgi-pass&quot;&gt;&lt;a href=&quot;#fastcgi-pass&quot; class=&quot;headerlink&quot; title=&quot;fastcgi_pass&quot;&gt;&lt;/a&gt;fastcgi_pass&lt;/h3&gt;&lt;p&gt;Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP Socket,一种是Unix Socket.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tcp Socket方式是IP加端口,可以跨服务器.而UNIX Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景，用哪种取决于你的PHP-FPM配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tcp Socket方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx.conf中配置：fastcgi_pass 127.0.0.1:9000;&lt;/p&gt;
&lt;p&gt;php-fpm.conf中配置：listen=127.0.0.1:9000;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unix Domain Socket方式:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx.conf中配置：fastcgi_pass unix:/tmp/php-fpm.sock;&lt;/p&gt;
&lt;p&gt;php-fpm中配置：listen = /tmp/php-fpm.sock；&lt;/p&gt;
&lt;p&gt;(php-fpm.sock是一个文件,由php-fpm生成)&lt;br&gt;&lt;strong&gt;&lt;br&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两种通信配置方式，Nginx和PHP-FPM的通信过程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tcp Socket：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nginx &amp;lt;=socket &amp;lt;=TCP/IP &amp;lt;=socket &amp;lt;=PHP-FPM
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(上边画Nginx和PHP-FPM通信的图时就是这种方式，这种情况是Nginx和PHP-FPM在同一台机器上)&lt;/p&gt;
&lt;p&gt;看一下Nginx和PHP-FPM不在同一台机器上的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nginx &amp;lt;=&amp;gt; socket &amp;lt;=&amp;gt; TCP/IP &amp;lt;=&amp;gt; 物理层 &amp;lt;=&amp;gt; 路由器 &amp;lt;=&amp;gt; 物理层 &amp;lt;=&amp;gt; 
TCP/IP &amp;lt;=&amp;gt; socket &amp;lt;=&amp;gt; PHP-FPM
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Unix Socket：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nginx &amp;lt;=&amp;gt; socket &amp;lt;=&amp;gt; PHP-FPM
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;include fastcgi_params;&lt;/strong&gt;&lt;br&gt;在nginx中有很多的fasgcgi*的配置，更多的配置可以在nginx.conf的同级目录中看到，在fastcgi.conf和fastcgiparams中，这两个的区别，上边有说明。看一下里边的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-9e8044d378df04f7e255662c51242885_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里边的内容都会被传递给PHP-FPM所管理的fastcgi进程。为什么会传递这些呢？相信大家都用过$SERVER这个全局变量，这里边的值就是从此配置中拿到的。我们可以在fastcgiparams中看到REMOTEADDR，就是客户端地址，PHP之所以能拿到客户端信息，就是因为Nginx的配置中的fastcgiparams。更多ngxhttpfastcgimodule模块的内容，可以看官方文档：&lt;a href=&quot;http://nginx.org/en/docs/http/ngxhttp_fastcgi_module.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nginx.org/en/docs/http/ngxhttp_fastcgi_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;php-fpm-conf配置&quot;&gt;&lt;a href=&quot;#php-fpm-conf配置&quot; class=&quot;headerlink&quot; title=&quot;php-fpm.conf配置&quot;&gt;&lt;/a&gt;php-fpm.conf配置&lt;/h2&gt;&lt;p&gt;熟悉php-fpm的配置，能帮助我们优化服务器性能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emergency_restart_threshold = 60
emergency_restart_interval = 60s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表示在emergencyrestartinterval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergencyrestartthreshold个，php-fpm就会优雅重启。这两个选项一般保持默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;process_control_timeout = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;listen = 127.0.0.1:9000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request_slowlog_timeout = 10s
#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 
设置为 ’0′ 表示 ‘Off’
slowlog = log/$pool.log.slow
慢请求的记录日志,配合request_slowlog_timeout使用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下边几个配置参数比较重要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pm
pm指的是process manager，指定进程管理器如何控制子进程的数量，它为必填项，支持3个值
(1)static: 使用固定的子进程数量，由pm.max_children指定(可以同时存活的子进程的最大数量)
(2)dynamic：基于下面的参数动态的调整子进程的数量，至少有一个子进程(会使用下边几个配置)
pm.start_servers: 启动时创建的子进程数量，默认值为min_spare_servers + max_spare_servers -
 min_spare_servers) / 2
pm.min_spare_servers: 空闲状态的子进程的最小数量，如果不足，新的子进程会被自动创建
pm.max_spare_servers: 空闲状态的子进程的最大数量，如果超过，一些子进程会被杀死
(3)ondemand: 启动时不会创建子进程，当新的请求到达时才创建，有下边两个配置
pm.max_children
pm.process_idle_timeout 子进程的空闲超时时间，如果超时时间到没有新的请求可以服务，则会被
杀死
区别：
如果pm设置为 static，那么其实只有pm.max_children这个参数生效。系统会开启设置数量的
php-fpm进程
如果pm设置为 dynamic，那么pm.max_children参数失效，后面3个参数生效
系统会在php-fpm运行开始 的时候启动pm.start_servers个php-fpm进程，
然后根据系统的需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数
还有一个比较重要的配置：
pm.max_requests
每一个子进程的最大请求服务数量，如果超过了这个值，该子进程会被自动重启。在解决第三方库的
内存泄漏问题时，这个参数会很有用。默认值为0，指子进程可以持续不断的服务请求
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;PHP-FPM进程池&quot;&gt;&lt;a href=&quot;#PHP-FPM进程池&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM进程池&quot;&gt;&lt;/a&gt;PHP-FPM进程池&lt;/h2&gt;&lt;p&gt;php-fpm.conf中默认配置了一个进程池，我们可以打开我们的php-fpm.conf看一下，下边是我的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-7365bfe451b0102092f528ea338dc5b6_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们执行一下:ps -aux|grep php-fpm&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-e62c2b5b0a6bef72d702cdc81fb82174_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;会看见有一个master，10个worker进程，和我们配置的一样（www为进程池名）&lt;/p&gt;
&lt;p&gt;想配置多个，这样做即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-56011c2443b60d0280be15ebd9df9ff9_720w.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在nginx中fastcgi_pass这个地方配置使用哪个进程池即可。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;原文参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/339250896&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎文章&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;用了这么久了PHP+Nginx了，你了解他们之间的通信原理吗？这一次做一回真正的PHPer（在上一篇文章里边已经全面介绍了CGI、FastC
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Nginx" scheme="http://isunman.com/tags/nginx/"/>
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
      <category term="lnmp" scheme="http://isunman.com/tags/lnmp/"/>
    
  </entry>
  
  <entry>
    <title>网络数字身份认证术</title>
    <link href="http://isunman.com/2023/05/16/network-digital-identity-authentication/"/>
    <id>http://isunman.com/2023/05/16/network-digital-identity-authentication/</id>
    <published>2023-05-16T12:15:00.000Z</published>
    <updated>2023-05-16T12:15:45.399Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章是&lt;a href=&quot;https://coolshell.cn/articles/19395.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《HTTP API 认证授权术》&lt;/a&gt;的姊妹篇，在那篇文章中，主要介绍了 HTTP API 认证和授权技术中用到的 HTTP Basic, Digest Access, HMAC, OAuth, JWT 等各种方式，主要是 API 上用到的一些技术，这篇文章主要想说的是另一个话题——身份认证。也就是说，怎么确认这个数据就是这个人发出来的？&lt;/p&gt;
&lt;h2 id=&quot;用户密码&quot;&gt;&lt;a href=&quot;#用户密码&quot; class=&quot;headerlink&quot; title=&quot;用户密码&quot;&gt;&lt;/a&gt;用户密码&lt;/h2&gt;&lt;p&gt;要解决这个问题，我们先来看一个最简单的解——使用密码，通常来说，在网络上要证明一个人的身份的话，都需要这个人的一些私密而唯一的东西。比如，像密码这样的东西，很多地方，只要你提供了你的用户名+密码，就可以确定这个人是你（注明：关于密码管理，强密码设定，密码泄漏，密码破解以及密码哄骗不在这篇文章的话题中），也就是说，这个密码是非常私密的事，我们可以假设，这个事全世界只能有当事人一个人知道，所以，当事人得供正确的密码，我们就可以认证这个人了。&lt;/p&gt;
&lt;p&gt;为了加强密码的安全程度，一般会使用 2FA（Two-factor authentication）或 MFA（Multi-factor authentication），双因认证或多因认证，这需要用户提供一个唯一的可信设备，比如用户的手机，然后通过验证手机短信，或是像 Google Authenticator  这样的动态口令来完成。这样的安全级别已经算是比较高了。如果能够再加上经常性的变更密码，那么安全级别就更好了。&lt;/p&gt;
&lt;p&gt;另外，一些公司还使用了生物密码来进行用户的身份验证，比如人脸识别。但是，我个人觉得人脸识别或是生物识别是比较糟糕的方式，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前能被验证的生物信息（如人脸和指纹）太容易被别人获得和伪造了。&lt;/li&gt;
&lt;li&gt;这样东西不能被变更和吊销，密码可以被吊销和重置，人脸则不能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;密钥对和证书&quot;&gt;&lt;a href=&quot;#密钥对和证书&quot; class=&quot;headerlink&quot; title=&quot;密钥对和证书&quot;&gt;&lt;/a&gt;密钥对和证书&lt;/h2&gt;&lt;p&gt;密码可以解决身证认证的问题有很多问题，最重要的一个问题就是，你要把你的密码提供给对方，对方才能验证你的身份。你不可能把你的密码提供给全世界的人吧，这样的话，全世界的人都有你的密码了，那么任何人都能变成你了。所以，用户密码这个事只能存在于权威机构和普通用户之间，不能存在于普遍应用中。所以，这里需要使用更好的解决方案。&lt;/p&gt;
&lt;p&gt;使用 ECC（Elliptic-Curve Cryptography）椭圆曲线密码术，可以通过一个“密钥对”进行非对称加密。这种技术，在对信息进行加密和解密时，使用两个不同的密钥，其中一个用来做加密，另一个做解密。这样一来，我们就可以把其中一个密钥公布出去，称之为公钥，另一个密钥私密地保管好，称之为私钥。&lt;/p&gt;
&lt;p&gt;比如，我用我的私钥加密信息，然后，我把这个私钥所配对的公钥发布给所有人，大家都用公钥解密信息，不用我的公钥你解密不了这个信息。这样一来，就可以保证这个信息是我发出来的，不但保证了信息安全，还完成了身份认证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2022/01/key.pair_-768x293.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样的现实案例一般用于网站，也就是用户得要知道我访问的这个网站是真实的，不是别人做的。因为 DNS 很容易被 hack，你连上一个不可信的网络，这个网络里的 DNS 把这个网站的 IP 地址解析成什么 就是什么了。但是有了这个加密的机制后，网站把自己的信息加密后连同公钥给到访问者，访问解密后就知道是不是这个网站了。&lt;/p&gt;
&lt;p&gt;但是，这里还是会有一个很严重的问题，那就是中间人攻击。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2022/01/key.pair_-768x293.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;中间人 Chad 把自己伪装成 Bob 向 Alice 要信息，然后，再伪装成 Alice 对 Bob 说，这就是 Alice 的公钥，于是 Bob 也无法验证是不是 Alice 的公钥，因为公钥里就是一堆乱七八糟的数据，我们完全不能分辨哪个公钥属于 Alice 的。试想，如果我们收到声称属于银行的密钥。我们怎么知道它确实属于你的银行？&lt;/p&gt;
&lt;p&gt;这里的答案就是&lt;strong&gt;使用数字证书&lt;/strong&gt;。证书跟我们的身份证非常类似，其需要一个可信机构来颁发和验证的。这个证书机构 CA（Certificate Authority）是一个是大家都相信的权威机构，他用他的人品保证（当然一般会被严格管理和审计），CA 机构同样使用这样的非对称加密的技术来完成颁发和验证的事。下图展示了这一过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2022/01/certificate-768x399.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明一下上面这个图：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了解决公钥认证的问题的，我们需要一个权威的CA 机构。&lt;/li&gt;
&lt;li&gt;Alice 把自己的信息（姓名、组织，地址，电邮，网址等）和自己的公钥打包成一个 CSR 的文件，发给 CA 机构，&lt;/li&gt;
&lt;li&gt;CA 机构会来找 Alice 做物理世界的认证，如果通过后，就会用自己的机构私钥，把CSR 变成一个签名证书。&lt;/li&gt;
&lt;li&gt;Bob 同学拿到 Alice 的证书，用 CA 机构的公钥解密后，得到 Alice 的公钥&lt;/li&gt;
&lt;li&gt;后面就可以签证 信息是否来自 Alice 了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是的，这个过程就是在“套娃”，这种证书机构还可以给下级的证书机构发证，于是就会一层套一层地，形成一个证书链，顶层的叫根证书，你得绝对信任之。对于验证证书真实性的客户端，它需要能够验证链中所有 CA 的签名，这意味着客户端需要访问链中所有 CA 的证书。&lt;/p&gt;
&lt;h2 id=&quot;证书生成过程演示&quot;&gt;&lt;a href=&quot;#证书生成过程演示&quot; class=&quot;headerlink&quot; title=&quot;证书生成过程演示&quot;&gt;&lt;/a&gt;证书生成过程演示&lt;/h2&gt;&lt;p&gt;并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 openssl命令来演示这个过程。&lt;/p&gt;
&lt;p&gt;1）生成 CA 的证书（公钥） ca.crt 和私钥 ca.key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl req -newkey rsa:2048 \
-new -nodes -x509 \
-days 365 \
-out ca.crt \
-keyout ca.key \
-subj &amp;quot;/C=SO/ST=Earth/L=Mountain/O=CoolShell/OU=HQ/CN=localhost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)  生成 alice 的私钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl genrsa -out alice.key 2048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3）生成 Alice 的 CSR – Certificate Signing Request&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl req -new -key alice.key 365 -out alice.csr \
-subj &amp;quot;/C=CN/ST=Beijing/L=Haidian/O=CoolShell/OU=Test/CN=localhost.alice&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4）使用 CA 给 Alice 签名证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl x509  -req -in alice.csr \
-extfile &amp;lt;(printf &amp;quot;subjectAltName=DNS:localhost.alice&amp;quot;) \ 
-CA ca.crt -CAkey ca.key  \
-days 365 -sha256 -CAcreateserial \
-out alice.crt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##双向认证 mTLS&lt;br&gt;上面，我们说的基本上都是单向认证，大量的场景都是确保用户方访问的是真正的服务方，如：银行，电商网站，等。这样可以保证用户不会被钓鱼网站或是中间人攻击。但是，很多时候，我们也是需要双向认证的。下面是一个典型的场景——微信支付和商户间交互&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户到商家那边买东西，商家要求用户进行支付。&lt;/li&gt;
&lt;li&gt;用户选择了微信支付，于是，界面从商户侧切到了微信侧&lt;/li&gt;
&lt;li&gt;微信那边支付完成后，商户这边收到微信那边支付完成的通知，于是开始发货。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个过程中有件事非常重要——就是微信通知商户支付完成的时候。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微信得确保通知到的就是用户所支付商户，而不是别个。&lt;/li&gt;
&lt;li&gt;商户也得要能确认，来通知我的就是微信，不是别人。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，微信会给商户一个 AppID和一个 AppSerct，用这个来确保是我认证过的商户来调用我，然后，需要商户在自己的系统里填一个回调的 URL，并通过平台设置的 key来做 MD5/HMAC的签名来确保是官方的回调。这都是在《HTTP API 认证授权术》中提到过的技术，是相对传统的技术。&lt;/p&gt;
&lt;p&gt;如今，&lt;strong&gt;mTLS&lt;/strong&gt;是确保云原生应用程序中服务之间的通信安全的首选协议。 也就是双向认证。&lt;/p&gt;
&lt;p&gt;传统的 TLS 认证过程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端连接到服务器&lt;/li&gt;
&lt;li&gt;服务器提供其 TLS 证书&lt;/li&gt;
&lt;li&gt;客户端验证服务器的证书&lt;/li&gt;
&lt;li&gt;客户端和服务器通过加密的 TLS 连接交换信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 mTLS 中，客户端和服务器都有一个证书，双方都使用他们的公钥/私钥对进行身份验证。与常规 TLS 相比，mTLS 中有额外的步骤来验证双方（以粗体显示的额外步骤）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端连接到服务器&lt;/li&gt;
&lt;li&gt;服务器提供其 TLS 证书&lt;/li&gt;
&lt;li&gt;客户端验证服务器的证书&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端出示其 TLS 证书&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器验证客户端的证书&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器授予访问权限&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端和服务器通过加密的 TLS 连接交换信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mTLS 需要“根”TLS 证书；这我们自己来完成证书颁发机构的职责。授权客户端和服务器使用的证书必须与此根证书相对应。根证书是自签名的，这意味着我们需要自己创建它。（注：此方法不适用于公共 Internet 上的单向 TLS，因为外部证书颁发机构必须颁发这些证书）&lt;/p&gt;
&lt;p&gt;那么，为什么整个互联网上都用了 TLS 了，为什么 不升级一下使用 mTLS？这里有两方面的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共互联网上要解决的问题是：A) 确保用户访问到的是正确的网站，而不是钓鱼网站。B）网站传输的内容是安全和私密且不会被篡改的。&lt;/li&gt;
&lt;li&gt;将 TLS 证书分发到所有最终用户设备将非常困难。生成、管理和验证为此所需的数十亿个证书几乎是不可能的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在较小的范围内，mTLS 对于单个组织非常有用且非常实用，尤其是当这些组织采用零信任方法来确保网络安全时。由于默认情况下零信任方法不信任任何用户、设备或请求，因此组织必须能够在每次尝试访问网络中的任何点时对每个用户、设备和请求进行身份验证。mTLS 通过对用户进行身份验证和设备验证来帮助实现这一目标。&lt;/p&gt;
&lt;p&gt;关于 mTLS，这里有一个我用 Golang 写的示例 – &lt;a href=&quot;https://github.com/haoel/mTLS，大家可以参考一下。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/haoel/mTLS，大家可以参考一下。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. 本文图版中的卡司来自安全圈的标准 Cast，参看 Alice and Bob。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://coolshell.cn/articles/21708.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《网络数字身份认证术》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是&lt;a href=&quot;https://coolshell.cn/articles/19395.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《HTTP API 认证授权术》&lt;/a&gt;的姊妹篇，在那篇文章中，主要介绍了 HTTP API 认证和
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="API" scheme="http://isunman.com/tags/api/"/>
    
      <category term="HTTP" scheme="http://isunman.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP API 认证授权术</title>
    <link href="http://isunman.com/2023/05/16/http-api-authentication-and-authorization/"/>
    <id>http://isunman.com/2023/05/16/http-api-authentication-and-authorization/</id>
    <published>2023-05-16T12:03:00.000Z</published>
    <updated>2023-05-16T12:05:41.669Z</updated>
    
    <content type="html">&lt;p&gt;我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。&lt;/p&gt;
&lt;p&gt;但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。注意，这是一篇长文！&lt;/p&gt;
&lt;p&gt;本篇文章会覆盖如下技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Basic&lt;/li&gt;
&lt;li&gt;Digest Access&lt;/li&gt;
&lt;li&gt;App Secret Key + HMAC&lt;/li&gt;
&lt;li&gt;JWT – JSON Web Tokens&lt;/li&gt;
&lt;li&gt;OAuth 1.0 – 3 legged &amp;amp; 2 legged&lt;/li&gt;
&lt;li&gt;OAuth 2.0 – Authentication Code &amp;amp; Client Credential&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HTTP-Basic&quot;&gt;&lt;a href=&quot;#HTTP-Basic&quot; class=&quot;headerlink&quot; title=&quot;HTTP Basic&quot;&gt;&lt;/a&gt;HTTP Basic&lt;/h2&gt;&lt;p&gt;HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication&lt;/p&gt;
&lt;p&gt;其技术原理如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、把 username和 password 做成  username:password 的样子（用冒号分隔）&lt;/p&gt;
&lt;p&gt;2、进行Base64编码。Base64(“username:password”) 得到一个字符串（如：把 haoel:coolshell 进行base64 后可以得到 aGFvZW86Y29vbHNoZWxsCg ）&lt;/p&gt;
&lt;p&gt;3、把 aGFvZW86Y29vbHNoZWxsCg放到HTTP头中 Authorization 字段中，形成 Authorization: Basic aGFvZW86Y29vbHNoZWxsCg，然后发送到服务端。&lt;/p&gt;
&lt;p&gt;4、服务端如果没有在头里看到认证字段，则返回401错，以及一个个WWW-Authenticate: Basic Realm=’HelloWorld’ 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 JIRA Cloud 的API认证支持HTTP Basic 这样的方式。&lt;/p&gt;
&lt;p&gt;但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。&lt;/p&gt;
&lt;h2 id=&quot;Digest-Access&quot;&gt;&lt;a href=&quot;#Digest-Access&quot; class=&quot;headerlink&quot; title=&quot;Digest Access&quot;&gt;&lt;/a&gt;Digest Access&lt;/h2&gt;&lt;p&gt;中文称“HTTP 摘要认证”，最初被定义在了 RFC 2069 文档中（后来被 RFC 2617 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。&lt;/p&gt;
&lt;p&gt;其基本思路是，请求方把用户名口令和域做一个MD5 –  MD5(username:realm:password) 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 nonce 另一个是 qop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，调用方发起一个普通的HTTP请求。比如：GET /coolshell/admin/ HTTP/1.1&lt;/li&gt;
&lt;li&gt;服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 WWW-Authenticate 包含如下信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;WWW-Authenticate: Digest realm=&amp;quot;testrealm@host.com&amp;quot;,
qop=&amp;quot;auth,auth-int&amp;quot;,
nonce=&amp;quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&amp;quot;,
opaque=&amp;quot;5ccc069c403ebaf9f0171e9517f40e41&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;其中的 nonce 为服务器端生成的随机数，然后，客户端做 HASH1=MD5(MD5(username:realm:password):nonce:cnonce) ，其中的 cnonce 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。&lt;/li&gt;
&lt;li&gt;如果 qop 中包含了 auth ，那么还得做  HASH2=MD5(method:digestURI) 其中的 method 就是HTTP的请求方法（GET/POST…），digestURI 是请求的URL。&lt;/li&gt;
&lt;li&gt;如果 qop 中包含了 auth-init ，那么，得做  HASH2=MD5(method:digestURI:MD5(entityBody)) 其中的 entityBody 就是HTTP请求的整个数据体。&lt;/li&gt;
&lt;li&gt;然后，得到 response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2) 如果没有 qop则 response = MD5(HA1:nonce:HA2)&lt;/li&gt;
&lt;li&gt;最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 Authorization: Digest …&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username=&amp;quot;Mufasa&amp;quot;,
 realm=&amp;quot;testrealm@host.com&amp;quot;,
 nonce=&amp;quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&amp;quot;,
 uri=&amp;quot;%2Fcoolshell%2Fadmin&amp;quot;,
 qop=auth,
 nc=00000001,
 cnonce=&amp;quot;0a4f113b&amp;quot;,
 response=&amp;quot;6629fae49393a05397450978507c4ef1&amp;quot;,
 opaque=&amp;quot;5ccc069c403ebaf9f0171e9517f40e41&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;维基百科上的 Wikipedia: Digest access authentication 词条非常详细地描述了这个细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是，&lt;strong&gt;别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击&lt;/strong&gt;——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。&lt;/p&gt;
&lt;h2 id=&quot;App-Secret-Key-HMAC&quot;&gt;&lt;a href=&quot;#App-Secret-Key-HMAC&quot; class=&quot;headerlink&quot; title=&quot;App Secret Key + HMAC&quot;&gt;&lt;/a&gt;App Secret Key + HMAC&lt;/h2&gt;&lt;p&gt;先说HMAC技术，这个东西来自于MAC – Message Authentication Code，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC – Hash-based Authenticsation Code，指的是利用Hash技术完成这一工作，比如：SHA-256算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/MAC-1024x634.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（图片来自 Wikipedia – MAC 词条 ）&lt;/p&gt;
&lt;p&gt;我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。&lt;/p&gt;
&lt;p&gt;把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过S3的API请求签名文档看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 CanonicalRequest，作个SHA-256的签名，然后再做一个base16的编码&lt;/li&gt;
&lt;li&gt;把上面的这个签名和签名算法 AWS4-HMAC-SHA256、时间戳、Scop，再打一个包，叫 StringToSign。&lt;/li&gt;
&lt;li&gt;准备签名，用 AWSSecretAccessKey来对日期签一个 DataKey，再用 DataKey 对要操作的Region签一个 DataRegionKey ，再对相关的服务签一个DataRegionServiceKey ，最后得到 SigningKey.&lt;/li&gt;
&lt;li&gt;用第三步的 SigningKey来对第二步的 StringToSign 签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/sigV4-using-query-params.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后，发出HTTP Request时，在HTTP头的 Authorization字段中放入如下的信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;Authorization: AWS4-HMAC-SHA256 
Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, 
SignedHeaders=content-type;host;x-amz-date, 
Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;其中的  AKIDEXAMPLE 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《Amazon S3 Rest API with curl》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。&lt;/p&gt;
&lt;p&gt;这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： Acquia 的 HMAC，微信的签名算法 （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 Authorization 里，而是放在body里）&lt;/p&gt;
&lt;h2 id=&quot;JWT-–-JSON-Web-Tokens&quot;&gt;&lt;a href=&quot;#JWT-–-JSON-Web-Tokens&quot; class=&quot;headerlink&quot; title=&quot;JWT – JSON Web Tokens&quot;&gt;&lt;/a&gt;JWT – JSON Web Tokens&lt;/h2&gt;&lt;p&gt;JWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（Message Authentication Code）的方法。JWT的签名流程一般是下面这个样子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户使用用户名和口令到认证服务器上请求认证。&lt;/li&gt;
&lt;li&gt;认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下：&lt;ul&gt;
&lt;li&gt;认证服务器还会生成一个 Secret Key（密钥）&lt;/li&gt;
&lt;li&gt;对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。&lt;/li&gt;
&lt;li&gt;用密钥对JWT签名 HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+’.’+Base64UrlEncode(JWT-Payload));&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.然后把 base64(header).base64(payload).signature 作为 JWT token返回客户端。&lt;/p&gt;
&lt;p&gt;4.客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。&lt;/p&gt;
&lt;p&gt;当应用服务器收到请求后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用服务会检查 JWT  Token，确认签名是正确的。&lt;/li&gt;
&lt;li&gt;然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。&lt;/li&gt;
&lt;li&gt;认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。&lt;/li&gt;
&lt;li&gt;认证服务器检查通过后，应用服务就可以认为这是合法请求了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC-SHA256的算法外，还支持RSA的非对称加密的算法。&lt;/p&gt;
&lt;p&gt;使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。&lt;/p&gt;
&lt;p&gt;最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。&lt;/p&gt;
&lt;p&gt;这里强烈建议全文阅读 Anglar 大学的 《JSW：The Complete Guide to JSON Web Tokens》&lt;/p&gt;
&lt;h2 id=&quot;OAuth-1-0&quot;&gt;&lt;a href=&quot;#OAuth-1-0&quot; class=&quot;headerlink&quot; title=&quot;OAuth 1.0&quot;&gt;&lt;/a&gt;OAuth 1.0&lt;/h2&gt;&lt;p&gt;OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：RFC 5849 （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 OAuth Core 1.0 Revision A ，我在下面做个大概的描述。&lt;/p&gt;
&lt;p&gt;根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个协议有三个角色：&lt;ul&gt;
&lt;li&gt;User（照片所有者-用户）&lt;/li&gt;
&lt;li&gt;Consumer（第三方照片打印服务）&lt;/li&gt;
&lt;li&gt;Service Provider（照片存储服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这个协义有三个阶段：&lt;ul&gt;
&lt;li&gt;Consumer获取Request Token&lt;/li&gt;
&lt;li&gt;Service Provider 认证用户并授权Consumer&lt;/li&gt;
&lt;li&gt;Consumer获取Access Token调用API访问用户的照片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个授权过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret&lt;/li&gt;
&lt;li&gt;当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）&lt;/li&gt;
&lt;li&gt;Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）&lt;/li&gt;
&lt;li&gt;Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。&lt;/li&gt;
&lt;li&gt;Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （oauth_token）和 Verification Code（oauth_verifier）&lt;/li&gt;
&lt;li&gt;接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)&lt;/li&gt;
&lt;li&gt;最后使用Access Token 访问用户授权访问的资源。&lt;br&gt;下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/oauth_graph.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret&lt;/li&gt;
&lt;li&gt;Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）&lt;/li&gt;
&lt;li&gt;Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret）&lt;/li&gt;
&lt;li&gt;Consumer 收到 Request Token 后，直接换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret)&lt;/li&gt;
&lt;li&gt;最后使用Access Token 访问用户授权访问的资源。&lt;br&gt;最后，再来说一说OAuth中的签名。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。&lt;/li&gt;
&lt;li&gt;签名密钥就是由这两具密钥拼接而成的，其中用 &amp;amp;作连接符。假设 Consumer Secret 为 j49sk3j29djd 而 Token Secret 为dh893hdasih9那个，签名密钥为：j49sk3j29djd&amp;amp;dh893hdasih9&lt;/li&gt;
&lt;li&gt;在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如：&lt;ul&gt;
&lt;li&gt;Consumer Key ： 也就是所谓的AppID&lt;/li&gt;
&lt;li&gt;Token： Request Token 或 Access Token&lt;/li&gt;
&lt;li&gt;Signature Method ：签名算法比如：HMAC-SHA1&lt;/li&gt;
&lt;li&gt;Timestamp：过期时间&lt;/li&gt;
&lt;li&gt;Nonce：随机字符串&lt;/li&gt;
&lt;li&gt;Call Back：回调URL&lt;br&gt;下图是整个签名的示意图：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/oauth_singature.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片还是比较直观的，我就不多解释了。&lt;/p&gt;
&lt;h2 id=&quot;OAuth-2-0&quot;&gt;&lt;a href=&quot;#OAuth-2-0&quot; class=&quot;headerlink&quot; title=&quot;OAuth 2.0&quot;&gt;&lt;/a&gt;OAuth 2.0&lt;/h2&gt;&lt;p&gt;在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求，&lt;strong&gt;这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制&lt;/strong&gt;，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。&lt;/p&gt;
&lt;p&gt;这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 RFC 6749 正式放出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的。&lt;/strong&gt;目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。&lt;/p&gt;
&lt;p&gt;下面，我们来重点看一下OAuth 2.0的两个主要的Flow：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是Authorization Code Flow， 这个是 3 legged 的&lt;/li&gt;
&lt;li&gt;一个是Client Credential Flow，这个是 2 legged 的。&lt;h3 id=&quot;Authorization-Code-Flow&quot;&gt;&lt;a href=&quot;#Authorization-Code-Flow&quot; class=&quot;headerlink&quot; title=&quot;Authorization Code Flow&quot;&gt;&lt;/a&gt;Authorization Code Flow&lt;/h3&gt;Authorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/auth_code_flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是对这个流程的一个细节上的解释：&lt;/p&gt;
&lt;p&gt;1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 /authorize API，其中的请求方式如下所示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;https://login.authorization-server.com/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&amp;amp;response_type=code
&amp;amp;redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F
&amp;amp;scope=read
&amp;amp;state=xcoiv98CoolShell3kch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;client_id为第三方应用的App ID&lt;/li&gt;
&lt;li&gt;response_type=code为告诉认证服务器，我要走Authorization Code Flow。&lt;/li&gt;
&lt;li&gt;redirect_uri意思是我跳转回第三方应用的URL&lt;/li&gt;
&lt;li&gt;scope意是相关的权限&lt;/li&gt;
&lt;li&gt;state 是一个随机的字符串，主要用于防CSRF攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）当Authorization Server收到这个URL请求后，其会通过 client_id来检查 redirect_uri和 scope是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。&lt;/p&gt;
&lt;p&gt;3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;https://example-client.com/callback?
code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&amp;amp;state=xcoiv98CoolShell3kch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请流动的链接是第 1）步中的 redirect_uri&lt;br&gt;其中的 state 的值也和第 1）步的 state一样。&lt;/p&gt;
&lt;p&gt;4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;POST /oauth/token HTTP/1.1
Host: authorization-server.com

code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&amp;amp;grant_type=code
&amp;amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F
&amp;amp;client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&amp;amp;client_secret=JqQX2PNo9bpM0uEihUPzyrh
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;5）如果没什么问题，Authorization 会返回如下信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;access_token&amp;quot;: &amp;quot;iJKV1QiLCJhbGciOiJSUzI1NiI&amp;quot;,
  &amp;quot;refresh_token&amp;quot;: &amp;quot;1KaPlrEqdFSBzjqfTGAMxZGU&amp;quot;,
  &amp;quot;token_type&amp;quot;: &amp;quot;bearer&amp;quot;,
  &amp;quot;expires&amp;quot;: 3600,
  &amp;quot;id_token&amp;quot;: &amp;quot;eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM...&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;access_token就是访问请求令牌了&lt;/li&gt;
&lt;li&gt;refresh_token用于刷新 access_token&lt;/li&gt;
&lt;li&gt;id_token 是JWT的token，其中一般会包含用户的OpenID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6）接下来就是用 Access Token 请求用户的资源了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;GET /v1/user/pictures
Host: https://example.resource.com

Authorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;Client-Credential-Flow&quot;&gt;&lt;a href=&quot;#Client-Credential-Flow&quot; class=&quot;headerlink&quot; title=&quot;Client Credential Flow&quot;&gt;&lt;/a&gt;Client Credential Flow&lt;/h3&gt;&lt;p&gt;Client Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。&lt;br&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/client_credentials_flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个过程非常简单，本质上就是Client用自己的 client_id和 client_secret向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。&lt;/p&gt;
&lt;p&gt;请求示例&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&amp;amp;client_id=czZCaGRSa3F0Mzpn
&amp;amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;access_token&amp;quot;:&amp;quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&amp;quot;,
  &amp;quot;token_type&amp;quot;:&amp;quot;bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot;:3600,
  &amp;quot;refresh_token&amp;quot;:&amp;quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&amp;quot;,
  &amp;quot;scope&amp;quot;:&amp;quot;create&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“微信公众号获取access token”），我截了个图如下所谓。我们可以看到，微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2019/05/wechat.dev_-1024x876.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;讲了这么多，我们来小结一下（下面的小结可能会有点散）&lt;/p&gt;
&lt;h3 id=&quot;两个术语和三个概念&quot;&gt;&lt;a href=&quot;#两个术语和三个概念&quot; class=&quot;headerlink&quot; title=&quot;两个术语和三个概念&quot;&gt;&lt;/a&gt;两个术语和三个概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;区分两个术语：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。&lt;/li&gt;
&lt;li&gt;区分三个概念：编码Base64Encode、签名HMAC、加密RSA。Base64编码是为了更好的传输（没有怪异的字符，可以传输二进制文件），等同于明文，HMAC签名是为了信息不能被篡改，RSA加密是为了不让别人看到是什么信息。&lt;h3 id=&quot;明白一些初衷&quot;&gt;&lt;a href=&quot;#明白一些初衷&quot; class=&quot;headerlink&quot; title=&quot;明白一些初衷&quot;&gt;&lt;/a&gt;明白一些初衷&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。&lt;/li&gt;
&lt;li&gt;JWT把 uid 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。&lt;/li&gt;
&lt;li&gt;OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。&lt;/li&gt;
&lt;li&gt;用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。&lt;/li&gt;
&lt;li&gt;OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。&lt;h3 id=&quot;相关的注意事项&quot;&gt;&lt;a href=&quot;#相关的注意事项&quot; class=&quot;headerlink&quot; title=&quot;相关的注意事项&quot;&gt;&lt;/a&gt;相关的注意事项&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 Authorization HTTP 头中。&lt;/li&gt;
&lt;li&gt;不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。&lt;/li&gt;
&lt;li&gt;密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。&lt;/li&gt;
&lt;li&gt;HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。&lt;/li&gt;
&lt;li&gt;最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。&lt;/li&gt;
&lt;li&gt;使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。&lt;/li&gt;
&lt;li&gt;密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。&lt;/li&gt;
&lt;li&gt;认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(全文完)&lt;/p&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://coolshell.cn/articles/19395.html&quot; title=&quot;HTTP API 认证授权术&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP API 认证授权术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文姊妹篇链接：&lt;a href=&quot;https://coolshell.cn/articles/21708.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《网络数字身份认证术》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="API" scheme="http://isunman.com/tags/api/"/>
    
      <category term="HTTP" scheme="http://isunman.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>聊聊团队协同和协同工具</title>
    <link href="http://isunman.com/2023/05/16/talk-about-teamwork-and-collaboration-tools/"/>
    <id>http://isunman.com/2023/05/16/talk-about-teamwork-and-collaboration-tools/</id>
    <published>2023-05-16T09:04:00.000Z</published>
    <updated>2023-05-16T09:05:57.183Z</updated>
    
    <content type="html">&lt;p&gt;这两天跟 Cali 和 Rather 做了一个线上的 Podcast – Ep.5 一起聊聊团队协同。主要是从 IM 工具扩展开来聊了一下团队的协同和相应的工具，但是聊天不是深度思考，有一些东西我没有讲透讲好，所以，我需要把我更多更完整更结构化的想法形成文字。（注：聊天聊地比较详细，本文只是想表达我的主要想法）&lt;/p&gt;
&lt;h2 id=&quot;国内外的企业-IM-的本质差别&quot;&gt;&lt;a href=&quot;#国内外的企业-IM-的本质差别&quot; class=&quot;headerlink&quot; title=&quot;国内外的企业 IM 的本质差别&quot;&gt;&lt;/a&gt;国内外的企业 IM 的本质差别&lt;/h2&gt;&lt;p&gt;国内企业级在线交流工具主要有：企业微信、钉钉、飞书，国外的则是：Slack、Discord这两大IM工具，你会发现，他们有很多不一样的东西，&lt;strong&gt;其中有两个最大的不同，一个是企业管理，一个是企业文化。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;企业管理&quot;&gt;&lt;a href=&quot;#企业管理&quot; class=&quot;headerlink&quot; title=&quot;企业管理&quot;&gt;&lt;/a&gt;企业管理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Slack/Discrod 主要是通过建 Channel ，而国内的IM则主要是拉群。&lt;/strong&gt;你可能会说，这不是一样的吗？其实是不一样的，很明显，Channel 的属性是相对持久的，而群的属性则是临时的，前者是可以是部门，可以是团队，可以是项目，可以是产品，可以是某种长期存在的职能（如：技术分享），而拉群则是相对来说临时起意的，有时候，同样的人群能被重复地拉出好几次，因为之前临时起意的事做完了，所以群就被人所遗忘了，后面再有事就再来。&lt;strong&gt;很明显，Channel 这种方式明显是有管理的属性的，而拉群则是没有管理的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在国内这种作坊式，野蛮粗放式的管理风格下，他们需要的就是想起一出是一出的 IM 工具，所以，拉群就是他们的工作习惯，因为没有科学的管理，所以没有章法，所以，他们不需要把工作内的信息结构化的工具。而国外则不然，国外的管理是精细化的，国外的公司还在重度使用 Email 的通讯方式，而 Email 是天生会给一个主题时行归类，而且 Email 天生不是碎片信息，所以，国外的 IM 需要跟 Email 竞争，因为像 Email 那样给邮件分类，把信息聚合在一个主题下的方式就能在 IM 上找到相关的影子。Channel 就是一个信息分类，相当于邮件分类，Slack 的 回复区和 Discord 的子区就像是把同一个主题信息时行聚合的功能。这明显是懂管理的人做的，而国内的拉群一看就是不懂管理的人干的，或者说是就是满足这些不懂管理的人的需求的。&lt;/p&gt;
&lt;h3 id=&quot;企业文化&quot;&gt;&lt;a href=&quot;#企业文化&quot; class=&quot;headerlink&quot; title=&quot;企业文化&quot;&gt;&lt;/a&gt;企业文化&lt;/h3&gt;&lt;p&gt;团队协作和团队工作最大的基石是信任，如果有了信任，没有工具都会很爽，如果没有信任，什么工具都没用。信任是一种企业文化，这种文化不仅包括同级间的，还包括上下级间的。但是，因为国内的管理跟不上，所以，就导致了各种不信任的文化，而需要在这里不信任的文化中进行协同工作，国内的 IM 软件就会开发出如下在国外的 IM 中完全没有的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控员工。&lt;/strong&gt;获取员工的工作时间以及工作位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有详细的已读标注。&lt;/strong&gt;这样会给对方要回复的压力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发出的信息不能修改，不能删除，非常有限地可撤回。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而国外的 IM 则是，发出的信息可以修改/删除，没有已读标准，也不会监控员工。这种时候，我总是会对工作在这种不信任文化中人感到可怜……如果大家需要靠逼迫的方式把对方拉来跟我一起协作，我们还工作个什么劲啊。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;所以，我们可以看到，&lt;strong&gt;畸形的企业管理和企业文化下，就会导致畸形的协同工具。&lt;/strong&gt;最令人感到悲哀的是，有好多同学还觉得国内的钉钉非常之好，殊不知，你之所以感觉好用，是因为你所在的环境是如此的不堪。你看，&lt;strong&gt;人到了不同的环境就会有不同的认识，所以，找一个好一些的环境对一个人的成长有多重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给一些新入行的人的建议就是，一个环境对一个人的认知会有非常大的影响，找一个好的环境是非常重要，如果不知道什么 环境是好的，那就先从不使用钉钉为工作协同软件的公司开始吧……&lt;/p&gt;
&lt;h2 id=&quot;什么是好的协同工具&quot;&gt;&lt;a href=&quot;#什么是好的协同工具&quot; class=&quot;headerlink&quot; title=&quot;什么是好的协同工具&quot;&gt;&lt;/a&gt;什么是好的协同工具&lt;/h2&gt;&lt;p&gt;我们从上面可以得到，协同的前提条件是你需要有一个基于信任的企业文化，还需要有有结构化思维的科学的管理思维。没有这两个东西，给你的团队再多的工具都不可能有真正好有协同的，大家就是装模作样罢了。&lt;/p&gt;
&lt;p&gt;假设我们的管理和文化都没有问题，那下面我们来谈谈协同工具的事。&lt;/p&gt;
&lt;p&gt;我个人觉得 IM 这种工具包括会议都不是一种好的协同工具，因为这些工具都无法把信息做到真正的结构化和准确化，用 IM 或是开会上的信息大多都是碎片化严重，而且没有经过深度思考或是准备的，基本都是即兴出来的东西，不靠谱的概率非常大。&lt;/p&gt;
&lt;p&gt;找人交流和开会不是有个话题就好的，还需要一个可以讨论的“议案”。在 Amazon 里开会，会前，组织方会把要讨论的方案打印出来给大家看，这个方案是深思过的，是验证过的，是有数据和证据或是引用支撑的，会议开始后，10 -15分钟是没有人说话的，大家都在看文档，然后就开始直接讨论或发表意见，支持还是不支持，还是有条件支持……会议效率就会很高。&lt;/p&gt;
&lt;p&gt;但是这个议案其实是可以由大家一起来完成的，所以，连打印或是开会都不需要。试想一下，使用像 Google Doc 这样的协同文档工具，把大家拉到同一个文档里直接创作，不香吗？我在前段时间，在公网上组织大家来帮我完成一个《非常时期的囤货手册》，这篇文章的形成有数百个网友的加持，而我就是在做一个主编的工作，这种工作是 IM 工具无法完成的事。与之类似的协同工具还有大家一起写代码的 Github，大家一起做设计的 Figma……这样创作类的协同工具非常多。另外，好多这些工具都能实时展示别人的创作过程，这个简直是太爽了，你可以通过观看他人创作过程，学习到很多他人的思路和想法，这个在没有协同工具的时代是很难想像的。&lt;/p&gt;
&lt;p&gt;好的协同工具是可以互相促进互相激励的，就像一个足球队一样，当你看到你的队友在勇敢地争抢，拼命地奔跑，你也会被感染到的。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;好的协同就是能够跟一帮志同道合，有共同目标，有想法，有能力的人一起做个什么事。所以，在我心中我最喜欢的协同工具从来都是创作类的，不是管理类的，更不是聊天类的。&lt;/strong&gt;管理和聊天的协同软件会让你产生一种有产出的假象，但其实不同，这种工具无论做的有多好，都是支持性的工具，不是产出类的工具，不会提升生产力的。&lt;/p&gt;
&lt;p&gt;另外，在创作类的协同工具上如果有一些智能小帮手，如：Github 发布的 Copilot。那简直是让人爽翻天了，所以，真正能提升生产力的工具都是在内容上帮得到你的。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;&lt;a href=&quot;#结束语&quot; class=&quot;headerlink&quot; title=&quot;结束语&quot;&gt;&lt;/a&gt;结束语&lt;/h2&gt;&lt;p&gt;我其实并不喜欢今天所有的 IM 工具，因为我觉得信息不是结构化的，信息是有因果关系和上下文的，是结构化的，是多维度的，不是今天这种线性的方式，我们想像一下“脑图”或是知识图，或是 wikipedia 的网关的关联，我们可能就能想像得到一个更好的 IM 应该是什么 样的……&lt;/p&gt;
&lt;p&gt;协同工作的想像空间实在是太大了，我觉得所有的桌面端的软件都会被协作版的重写，虽然，这种协作软件需要有网络的加持，但是协作软件的魅力和诱惑力实在的太大了，让人无法不从……&lt;/p&gt;
&lt;p&gt;未来的企业，那些管理类的工具一定会被边缘化的，聊天类的会被打成一个通知中心，而创作类的会大放异彩，让大家直接在要干的事上进行沟通、交互和分享。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://coolshell.cn/articles/22298.html&quot; title=&quot;聊聊团队协同和协同工具&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;聊聊团队协同和协同工具&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这两天跟 Cali 和 Rather 做了一个线上的 Podcast – Ep.5 一起聊聊团队协同。主要是从 IM 工具扩展开来聊了一下团队的协同和相应的工具，但是聊天不是深度思考，有一些东西我没有讲透讲好，所以，我需要把我更多更完整更结构化的想法形成文字。（注：聊天聊地
    
    </summary>
    
      <category term="产品研究" scheme="http://isunman.com/categories/%E4%BA%A7%E5%93%81%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="产品" scheme="http://isunman.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="思考" scheme="http://isunman.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>PHP中怎么使用fsockopen实现异步请求与响应状态码499</title>
    <link href="http://isunman.com/2022/08/21/How-to-use-FSOCKOPEN-in-PHP-to-achieve-asynchronous-request-and-response-status-code-499/"/>
    <id>http://isunman.com/2022/08/21/How-to-use-FSOCKOPEN-in-PHP-to-achieve-asynchronous-request-and-response-status-code-499/</id>
    <published>2022-08-20T17:46:00.000Z</published>
    <updated>2022-08-20T17:54:54.196Z</updated>
    
    <content type="html">&lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;在PHP中使用fsockopen实现异步请求时，发现请求有发出，但是响应不是200而是499，导致被请求脚本并未按要求执行。&lt;/p&gt;
&lt;h3 id=&quot;这个问题的起源与解决方案。&quot;&gt;&lt;a href=&quot;#这个问题的起源与解决方案。&quot; class=&quot;headerlink&quot; title=&quot;这个问题的起源与解决方案。&quot;&gt;&lt;/a&gt;这个问题的起源与解决方案。&lt;/h3&gt;&lt;p&gt;php中怎么使用fsockopen实现异步请求，相信很多没有经验的人对此束手无策，为此本文总结了问题出现的原因和解决方法，通过这篇文章希望你能解决这个问题。&lt;/p&gt;
&lt;p&gt;php执行一段程序，有可能几毫秒就执行完毕，也有可能耗时较长。&lt;/p&gt;
&lt;p&gt;例如，用户下单这个事件，如果调用了些第三方服务进行发邮件、短信、推送等通知，可能导致前端一直在等待。&lt;/p&gt;
&lt;p&gt;而有的时候，我们并不关心这些耗时脚本的返回结果，只要执行就行了。这时候就需要采用异步的方式执行。&lt;/p&gt;
&lt;p&gt;众所周知，PHP没有直接支持多线程这种东西。我们可以采用折衷的方式实现。这里主要说的就是fsockopen。&lt;/p&gt;
&lt;p&gt;通过fsockopen发送请求并忽略返回结果，程序可以马上返回。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$fp = fsockopen(&amp;quot;www.example.com&amp;quot;, 80, $errno, $errstr, 30);
if (!$fp) {
       echo &amp;quot;$errstr ($errno)&amp;lt;br /&amp;gt;\n&amp;quot;;
} else {
       $out = &amp;quot;GET /backend.php   HTTP/1.1\r\n&amp;quot;;
    $out .= &amp;quot;Host: www.example.com\r\n&amp;quot;;
    $out .= &amp;quot;Connection: Close\r\n\r\n&amp;quot;;

    fwrite($fp, $out);
    /*忽略执行结果
    while (!feof($fp)) {
        echo fgets($fp, 128);
    }*/
       fclose($fp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是我们需要手动拼出header头信息。通过打开注释部分，可以查看请求返回结果，但这时候又变成同步的了，因为程序会等待返回结果才结束。&lt;/p&gt;
&lt;h3 id=&quot;实际测试遇到的问题&quot;&gt;&lt;a href=&quot;#实际测试遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;实际测试遇到的问题&quot;&gt;&lt;/a&gt;实际测试遇到的问题&lt;/h3&gt;&lt;p&gt;实际测试的时候发现，不忽略执行结果，调试的时候每次都会成功发送sock请求；但忽略执行结果，经常看到没有成功发送sock请求。查看nginx日志，发现很多状态码为499的请求。&lt;/p&gt;
&lt;p&gt;后来找到了原因：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fwrite&lt;/code&gt;之后马上执行&lt;code&gt;fclose&lt;/code&gt;，nginx会直接返回499，不会把请求转发给php处理。&lt;/p&gt;
&lt;p&gt;客户端主动端口请求连接时，NGINX 不会将该请求代理给上游服务（FastCGI PHP 进程），这个时候 access log 中会以 499 记录这个请求。&lt;/p&gt;
&lt;h3 id=&quot;解决方案：&quot;&gt;&lt;a href=&quot;#解决方案：&quot; class=&quot;headerlink&quot; title=&quot;解决方案：&quot;&gt;&lt;/a&gt;解决方案：&lt;/h3&gt;&lt;p&gt;1)nginx.conf增加配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#忽略客户端中断
fastcgi_ignore_client_abort on;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)fwrite之后使用usleep函数休眠20毫秒：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usleep(20000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后来测试就没有发现失败的情况了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yisu.com/zixun/367919.html&quot; title=&quot;参考文章1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考文章1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/panjiapengfly/article/details/103010517&quot; title=&quot;参考文章2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考文章2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wang_quan_li/article/details/41806529&quot; title=&quot;参考文章3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考文章3&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;在PHP中使用fsockopen实现异步请求时，发现请求有发出，但是响应不是200而是499，导致被请求脚本并未按要求执行。&lt;/p&gt;
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Nginx" scheme="http://isunman.com/tags/nginx/"/>
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>云盘在线扩容</title>
    <link href="http://isunman.com/2022/05/31/online-capacity-expansion-of-cloud-disks/"/>
    <id>http://isunman.com/2022/05/31/online-capacity-expansion-of-cloud-disks/</id>
    <published>2022-05-31T03:15:00.000Z</published>
    <updated>2022-05-31T03:18:39.527Z</updated>
    
    <content type="html">&lt;p&gt;在线扩容，是在磁盘不够用时，直接不停机不停服的情况下扩展磁盘空间。&lt;/p&gt;
&lt;p&gt;非常好用。不过，需要系统支持。&lt;/p&gt;
&lt;h3 id=&quot;一、扩容概述（官网说明）&quot;&gt;&lt;a href=&quot;#一、扩容概述（官网说明）&quot; class=&quot;headerlink&quot; title=&quot;一、扩容概述（官网说明）&quot;&gt;&lt;/a&gt;一、扩容概述（官网说明）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/35095.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://help.aliyun.com/document_detail/35095.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是是前提，包括：扩容场景、系统盘扩容上限、数据盘扩容上限、扩容计费等。&lt;br&gt;是在进行技术操作前的一些须知与准备工作。&lt;br&gt;确认在用的ECS实例与云盘支持“在线扩容”之后，才能进行后续的操作。&lt;/p&gt;
&lt;h3 id=&quot;二、在线扩容云盘（Linux系统）（官网说明）&quot;&gt;&lt;a href=&quot;#二、在线扩容云盘（Linux系统）（官网说明）&quot; class=&quot;headerlink&quot; title=&quot;二、在线扩容云盘（Linux系统）（官网说明）&quot;&gt;&lt;/a&gt;二、在线扩容云盘（Linux系统）（官网说明）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/113316.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://help.aliyun.com/document_detail/113316.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是具体的执行Linux系统的云盘“在线扩容”的详细步骤。&lt;br&gt;包括：前提条件，背景信息，操作步骤，支持在线扩容的操作系统，常见问题，其他扩容场景。&lt;/p&gt;
&lt;p&gt;其中【操作步骤】又包括：&lt;br&gt;步骤一：创建快照；&lt;br&gt;步骤二：在控制台扩容云盘容量；&lt;br&gt;步骤三：查看云盘分区情况；&lt;br&gt;步骤四：扩容分区；&lt;br&gt;步骤五：扩容文件系统。&lt;/p&gt;
&lt;h3 id=&quot;三、实际操作步骤【关键】（实际操作）&quot;&gt;&lt;a href=&quot;#三、实际操作步骤【关键】（实际操作）&quot; class=&quot;headerlink&quot; title=&quot;三、实际操作步骤【关键】（实际操作）&quot;&gt;&lt;/a&gt;三、实际操作步骤【关键】（实际操作）&lt;/h3&gt;&lt;p&gt;1、例子：扩容/dev/vda 由80G扩容到160G&lt;/p&gt;
&lt;p&gt;在阿里云上进行在线扩容操作 ：&lt;/p&gt;
&lt;p&gt;存储与快照 &amp;gt; 云盘页面选择云盘后，单击云盘扩容，选中在线扩容，并设置扩容后容量&lt;br&gt;Linux上执行命令&lt;/p&gt;
&lt;p&gt;2、查看磁盘信息：&lt;code&gt;fdisk -l&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、查看要扩容的分区的文件系统类型：&lt;code&gt;df -hT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4、安装growpart工具&lt;br&gt;CentOS 7及以上版本：运行命令 &lt;code&gt;yum install cloud-utils-growpart&lt;/code&gt;&lt;br&gt;Debian 9及以上版本、Ubuntu14及以上版本：运行命令 &lt;code&gt;apt install -y cloud-guest-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5、运行命令，扩容分区：&lt;code&gt;growpart /dev/vda 1&lt;/code&gt;（1前面有空格）&lt;/p&gt;
&lt;p&gt;6、扩容文件系统：&lt;code&gt;resize2fs /dev/vda1&lt;/code&gt; （这里1前面没有空格）&lt;/p&gt;
&lt;p&gt;7、查看是否扩容成功：&lt;code&gt;df -hT&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、几个问题的解决&quot;&gt;&lt;a href=&quot;#四、几个问题的解决&quot; class=&quot;headerlink&quot; title=&quot;四、几个问题的解决&quot;&gt;&lt;/a&gt;四、几个问题的解决&lt;/h3&gt;&lt;p&gt;1、问题出现在上述详细步骤的“4、安装growpart工具”这一步，由于CentOS8不再被支持，而造成了yum源错误的问题。&lt;/p&gt;
&lt;p&gt;错误提示为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error:Failed to download metadata for repo &amp;#39;AppStream&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;由于CentOS 8操作系统版本结束了生命周期而导致YUM源出错的问题：&lt;br&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/405635.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://help.aliyun.com/document_detail/405635.htm&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在线扩容，是在磁盘不够用时，直接不停机不停服的情况下扩展磁盘空间。&lt;/p&gt;
&lt;p&gt;非常好用。不过，需要系统支持。&lt;/p&gt;
&lt;h3 id=&quot;一、扩容概述（官网说明）&quot;&gt;&lt;a href=&quot;#一、扩容概述（官网说明）&quot; class=&quot;headerlink&quot; title=&quot;一、扩容
    
    </summary>
    
      <category term="服务器" scheme="http://isunman.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://isunman.com/tags/linux/"/>
    
      <category term="阿里云" scheme="http://isunman.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>苹果开发者账号的类型与发布方式</title>
    <link href="http://isunman.com/2022/04/27/type-of-Apple-developer-account-and-distribution-method/"/>
    <id>http://isunman.com/2022/04/27/type-of-Apple-developer-account-and-distribution-method/</id>
    <published>2022-04-27T08:42:00.000Z</published>
    <updated>2022-04-27T19:08:16.736Z</updated>
    
    <content type="html">&lt;p&gt;苹果开发者账号的类型与发布方式&lt;/p&gt;
&lt;h2 id=&quot;开发者账号类型&quot;&gt;&lt;a href=&quot;#开发者账号类型&quot; class=&quot;headerlink&quot; title=&quot;开发者账号类型&quot;&gt;&lt;/a&gt;开发者账号类型&lt;/h2&gt;&lt;p&gt;苹果开发者账号有个人版（99美金/年），公司版（99美金/年）和企业版（299美金/年）三种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;99美金属于标准计划；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准计划还分为标准个人计划和标准公司计划，区别是：如登记为标准个人计划（个人开发者），则应用程序商店中的“seller name”将显示您个人的名称，如登记为标准公司计划（公司开发者）则应用程序商店中的“seller name”将显示公司的法定名称，同时您可以把其他会员添加到开发团队。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;299美金属于企业计划。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、99美金个人开发者账号：&quot;&gt;&lt;a href=&quot;#一、99美金个人开发者账号：&quot; class=&quot;headerlink&quot; title=&quot;一、99美金个人开发者账号：&quot;&gt;&lt;/a&gt;一、99美金个人开发者账号：&lt;/h3&gt;&lt;p&gt;1、开发者能够自由地创造iPhone / iPod Touch/ iPad的商业应用，并且能够发布他们的应用程序（免费或收费）在App Store上&lt;/p&gt;
&lt;p&gt;2、App Store中的“seller name”将显示您个人的名称&lt;/p&gt;
&lt;p&gt;3、每年可以设置100台测试机做开发及测试用&lt;/p&gt;
&lt;p&gt;4、不允许开发人员创建一个团队&lt;/p&gt;
&lt;h3 id=&quot;二、99美金公司开发者账号：&quot;&gt;&lt;a href=&quot;#二、99美金公司开发者账号：&quot; class=&quot;headerlink&quot; title=&quot;二、99美金公司开发者账号：&quot;&gt;&lt;/a&gt;二、99美金公司开发者账号：&lt;/h3&gt;&lt;p&gt;1、开发者能够自由地创造iPhone / iPod Touch/ iPad的商业应用，并且能够发布他们的应用程序（免费或收费）在App Store上&lt;/p&gt;
&lt;p&gt;2、App Store中的“seller name”将显示公司的法定名称&lt;/p&gt;
&lt;p&gt;3、每年可以设置100台测试机做开发及测试用&lt;/p&gt;
&lt;p&gt;4、允许开发人员创建一个团队，可以把其他成员添加到开发团队&lt;/p&gt;
&lt;p&gt;5、公司应在邓白氏注册并拥有有效的DUNS号码&lt;/p&gt;
&lt;p&gt;删除Provisioning Profiles,appid,发布证书的后果:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果app已经上线发布至App Store了，那么此时删除开发者账号的证书和描述文件对已经上线的app来说没什么大的影响，app可以正常使用。如果app在开发阶段，此时删除证书和描述文件，应该是不行的，上架估计都不会通过。&lt;/p&gt;
&lt;p&gt;没有实际测试过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、299美金企业开发者账号：&quot;&gt;&lt;a href=&quot;#三、299美金企业开发者账号：&quot; class=&quot;headerlink&quot; title=&quot;三、299美金企业开发者账号：&quot;&gt;&lt;/a&gt;三、299美金企业开发者账号：&lt;/h3&gt;&lt;p&gt;1、不允许该企业在App Store出售他们的应用程序&lt;/p&gt;
&lt;p&gt;2、所开发的应用只能发给其雇员作内部使用&lt;/p&gt;
&lt;p&gt;3、UDID数量不限制&lt;/p&gt;
&lt;p&gt;4、允许开发人员创建一个团队，团队成员添加到他们的帐户&lt;/p&gt;
&lt;p&gt;5、公司应在邓白氏注册并拥有有效的DUNS号码（面向拥有500雇员以上的公司）&lt;/p&gt;
&lt;p&gt;删除Provisioning Profiles,appid,发布证书的后果:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有已经安装的app不能打开，会闪退，在线itms-services协议不能安装&lt;/p&gt;
&lt;p&gt;所以企业应用安装到手机上则需要开发者账号上的证书和描述文件来通过手机的验证，此时删除证书和描述文件，则无法通过手机的验证，app也就无法使用了。此时下载的话则无法进行安装，会显示Unable to download app，选择Done或Retry。&lt;/p&gt;
&lt;p&gt;但是我测试了删除了appid和发布证书,app没有任何影响,放在fir还是能下载安装,不知道是不是删除时间太短(删除3天了  还是能用)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;发布方式（4种）：&quot;&gt;&lt;a href=&quot;#发布方式（4种）：&quot; class=&quot;headerlink&quot; title=&quot;发布方式（4种）：&quot;&gt;&lt;/a&gt;发布方式（4种）：&lt;/h2&gt;&lt;h3 id=&quot;一、苹果应用商店发布（App-Store）&quot;&gt;&lt;a href=&quot;#一、苹果应用商店发布（App-Store）&quot; class=&quot;headerlink&quot; title=&quot;一、苹果应用商店发布（App Store）&quot;&gt;&lt;/a&gt;一、苹果应用商店发布（App Store）&lt;/h3&gt;&lt;h3 id=&quot;二、苹果应用商店批量购买发布（Volume-Purchase-Program）&quot;&gt;&lt;a href=&quot;#二、苹果应用商店批量购买发布（Volume-Purchase-Program）&quot; class=&quot;headerlink&quot; title=&quot;二、苹果应用商店批量购买发布（Volume Purchase Program）&quot;&gt;&lt;/a&gt;二、苹果应用商店批量购买发布（Volume Purchase Program）&lt;/h3&gt;&lt;h3 id=&quot;三、In-House企业应用发布：&quot;&gt;&lt;a href=&quot;#三、In-House企业应用发布：&quot; class=&quot;headerlink&quot; title=&quot;三、In-House企业应用发布：&quot;&gt;&lt;/a&gt;三、In-House企业应用发布：&lt;/h3&gt;&lt;p&gt;1、不能提交到App Store&lt;/p&gt;
&lt;p&gt;2、发布应用的具体内容不需要苹果官方审核&lt;/p&gt;
&lt;p&gt;3、安装设备的数量没有任何限制&lt;/p&gt;
&lt;p&gt;4、把程序放在网站中，提供给最终用户一个链接，他们就能够直接下载并自动安装了&lt;/p&gt;
&lt;h3 id=&quot;四、Ad-Hoc应用发布方式&quot;&gt;&lt;a href=&quot;#四、Ad-Hoc应用发布方式&quot; class=&quot;headerlink&quot; title=&quot;四、Ad Hoc应用发布方式&quot;&gt;&lt;/a&gt;四、Ad Hoc应用发布方式&lt;/h3&gt;&lt;p&gt;1、不能提交到App Store&lt;/p&gt;
&lt;p&gt;2、不需要经过苹果的评审，&lt;/p&gt;
&lt;p&gt;3、限制每个应用不能发布到超过100个设备上&lt;/p&gt;
&lt;p&gt;4、把程序放在网站中，提供给最终用户一个链接，他们就能够直接下载并自动安装了&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/87d9e4259846&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;苹果开发者账号的类型与发布方式&lt;/p&gt;
&lt;h2 id=&quot;开发者账号类型&quot;&gt;&lt;a href=&quot;#开发者账号类型&quot; class=&quot;headerlink&quot; title=&quot;开发者账号类型&quot;&gt;&lt;/a&gt;开发者账号类型&lt;/h2&gt;&lt;p&gt;苹果开发者账号有个人版（99美金/年），公司版（99美
    
    </summary>
    
      <category term="iOS" scheme="http://isunman.com/categories/ios/"/>
    
    
      <category term="iOS" scheme="http://isunman.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>linux查找并移动文件</title>
    <link href="http://isunman.com/2021/08/15/linux-finds-and-move-files/"/>
    <id>http://isunman.com/2021/08/15/linux-finds-and-move-files/</id>
    <published>2021-08-15T03:48:00.000Z</published>
    <updated>2022-04-27T08:56:23.922Z</updated>
    
    <content type="html">&lt;p&gt;linux查找并移动文件&lt;/p&gt;
&lt;h3 id=&quot;原文参考&quot;&gt;&lt;a href=&quot;#原文参考&quot; class=&quot;headerlink&quot; title=&quot;原文参考&quot;&gt;&lt;/a&gt;原文参考&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;find . -name &amp;apos;10-*.dat&amp;apos; -exec mv {} ../ \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里：&lt;/p&gt;
&lt;p&gt;=&amp;gt; -exec mv {} /mnt/mp3 \; - 运行mv命令。&lt;/p&gt;
&lt;p&gt;=&amp;gt; {} - 字符 ‘{}’ 代表find到的所有内容。&lt;/p&gt;
&lt;p&gt;=&amp;gt;../表示当前用户目录的上一级目录&lt;/p&gt;
&lt;p&gt;=&amp;gt; \; - 结束 /bin/mv 命令。&lt;/p&gt;
&lt;h3 id=&quot;亲测可用&quot;&gt;&lt;a href=&quot;#亲测可用&quot; class=&quot;headerlink&quot; title=&quot;亲测可用&quot;&gt;&lt;/a&gt;亲测可用&lt;/h3&gt;&lt;p&gt;移动搜索匹配条件的文件到指定目录&lt;/p&gt;
&lt;p&gt;查找并移动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name &amp;apos;faverifyimage_*.png&amp;apos; -exec mv {} ../ \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name &amp;apos;faverifyimage_*.png&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下命令是：&lt;/p&gt;
&lt;p&gt;移动【当前目录下（不含子目录）】【以faverifyimage_开头的图片文件】到【faverifyimgbk】目录。&lt;/p&gt;
&lt;p&gt;说明：扩展了“不含子目录”这个条件，只操作“当前目录”；同时，继续执行了其他格式的图片文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -maxdepth 1 -name &amp;apos;faverifyimage_*.png&amp;apos; -exec mv {} ./faverifyimgbk \;
find . -maxdepth 1 -name &amp;apos;faverifyimage_*.jpg&amp;apos; -exec mv {} ./faverifyimgbk \;
find . -maxdepth 1 -name &amp;apos;faverifyimage_*.jpeg&amp;apos; -exec mv {} ./faverifyimgbk \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/p&gt;
&lt;p&gt;之后好久没更新。&lt;/p&gt;
&lt;h1 id=&quot;因为github在2021年08月13日之后停止了账号密码的登录机制。&quot;&gt;&lt;a href=&quot;#因为github在2021年08月13日之后停止了账号密码的登录机制。&quot; class=&quot;headerlink&quot; title=&quot;因为github在2021年08月13日之后停止了账号密码的登录机制。&quot;&gt;&lt;/a&gt;因为github在2021年08月13日之后停止了账号密码的登录机制。&lt;/h1&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1005c8acaffa52e5d81b9fff2815f3f1febb6fdc
　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;linux查找并移动文件&lt;/p&gt;
&lt;h3 id=&quot;原文参考&quot;&gt;&lt;a href=&quot;#原文参考&quot; class=&quot;headerlink&quot; title=&quot;原文参考&quot;&gt;&lt;/a&gt;原文参考&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;find . -name &amp;apos;10-*.dat&amp;apos; 
    
    </summary>
    
      <category term="服务器" scheme="http://isunman.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://isunman.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP浮点数计算必须使用PHP提供的高精度计算函数</title>
    <link href="http://isunman.com/2021/06/07/PHP-floating-point-calculations-must-use-the-high-precision-calculation-functions-provided-by-PHP/"/>
    <id>http://isunman.com/2021/06/07/PHP-floating-point-calculations-must-use-the-high-precision-calculation-functions-provided-by-PHP/</id>
    <published>2021-06-07T02:38:00.000Z</published>
    <updated>2021-06-07T02:40:06.975Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、前方有坑&quot;&gt;&lt;a href=&quot;#一、前方有坑&quot; class=&quot;headerlink&quot; title=&quot;一、前方有坑&quot;&gt;&lt;/a&gt;一、前方有坑&lt;/h3&gt;&lt;p&gt;php在使用加减乘除等运算符计算浮点数的时候，经常会出现意想不到的结果，特别是关于财务数据方面的计算，给不少工程师惹了很多的麻烦。比如今天工作终于到的一个案例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$a = 2586;

$b = 2585.98;

var_dump($a-$b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;期望的结果是：float(0.02)&lt;/p&gt;
&lt;p&gt;实际结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float(0.019999999999982)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;人生有坑，处处提防&lt;/p&gt;
&lt;h3 id=&quot;二、防坑攻略：&quot;&gt;&lt;a href=&quot;#二、防坑攻略：&quot; class=&quot;headerlink&quot; title=&quot;二、防坑攻略：&quot;&gt;&lt;/a&gt;二、防坑攻略：&lt;/h3&gt;&lt;p&gt;1、通过乘100的方式转化为整数加减，然后在除以100转化回来……&lt;/p&gt;
&lt;p&gt;2、使用number_format转化成字符串，然后在使用（float）强转回来……&lt;/p&gt;
&lt;p&gt;3、php提供了高精度计算的函数库，实际上就是为了解决这个浮点数计算问题而生的。&lt;/p&gt;
&lt;p&gt;主要函数有：&lt;/p&gt;
&lt;p&gt;bcadd — 将两个高精度数字相加&lt;/p&gt;
&lt;p&gt;bccomp — 比较两个高精度数字，返回-1, 0, 1&lt;/p&gt;
&lt;p&gt;bcdiv — 将两个高精度数字相除&lt;/p&gt;
&lt;p&gt;bcmod — 求高精度数字余数&lt;/p&gt;
&lt;p&gt;bcmul — 将两个高精度数字相乘&lt;/p&gt;
&lt;p&gt;bcpow — 求高精度数字乘方&lt;/p&gt;
&lt;p&gt;bcpowmod — 求高精度数字乘方求模，数论里非常常用&lt;/p&gt;
&lt;p&gt;bcscale — 配置默认小数点位数，相当于就是Linux bc中的”scale=”&lt;/p&gt;
&lt;p&gt;bcsqrt — 求高精度数字平方根&lt;/p&gt;
&lt;p&gt;bcsub — 将两个高精度数字相减&lt;/p&gt;
&lt;p&gt;前两种流氓的办法就不测试了，使用bcsub测试第三种两数相减的例子，&lt;/p&gt;
&lt;p&gt;先看bcsub用法（来自官网）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string bcsub ( string $left_operand , string $right_operand [, int $scale = int ] )

参数

left_operand 字符串类型的左操作数.

right_operand 字符串类型的右操作数.

scale 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。

返回值 返回减法之后结果为字符串类型.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var_dump(bcsub($a,$b,2));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.02
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他的函数请参考PHP官方网站&lt;/p&gt;
&lt;h3 id=&quot;三、为啥有坑：&quot;&gt;&lt;a href=&quot;#三、为啥有坑：&quot; class=&quot;headerlink&quot; title=&quot;三、为啥有坑：&quot;&gt;&lt;/a&gt;三、为啥有坑：&lt;/h3&gt;&lt;p&gt;php的bug?不是，这是所有语言基本上都会遇到的问题，所以基本上大部分语言都提供了精准计算的类库或函数库。&lt;/p&gt;
&lt;p&gt;要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754):&lt;/p&gt;
&lt;p&gt;浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位).&lt;/p&gt;
&lt;p&gt;符号位：最高位表示数据的正负，0表示正数，1表示负数。&lt;/p&gt;
&lt;p&gt;指数位：表示数据以2为底的幂，指数采用偏移码表示&lt;/p&gt;
&lt;p&gt;尾数：表示数据小数点后的有效数字.&lt;/p&gt;
&lt;p&gt;这里的关键点就在于, 小数在二进制的表示, 小数如何转化为二进制呢？&lt;/p&gt;
&lt;p&gt;算法是乘以2直到没有了小数为止。这里举个例子，0.9表示成二进制数&lt;/p&gt;
&lt;p&gt;0.9*2=1.8 取整数部分 1&lt;/p&gt;
&lt;p&gt;0.8(1.8的小数部分)*2=1.6 取整数部分 1&lt;/p&gt;
&lt;p&gt;0.6*2=1.2 取整数部分 1&lt;/p&gt;
&lt;p&gt;0.2*2=0.4 取整数部分 0&lt;/p&gt;
&lt;p&gt;0.4*2=0.8 取整数部分 0&lt;/p&gt;
&lt;p&gt;0.8*2=1.6 取整数部分 1&lt;/p&gt;
&lt;p&gt;0.6*2=1.2 取整数部分 0&lt;/p&gt;
&lt;p&gt;………&lt;/p&gt;
&lt;p&gt;0.9二进制表示为(从上往下): 1100100100100……&lt;/p&gt;
&lt;p&gt;注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了”减不尽”的精度丢失问题。&lt;/p&gt;
&lt;p&gt;换句话说：我们看到十进制小数，在计算机内存储的不是一个精确的数字，也不可能精确。所以在数字加减乘除后出现意想不到的结果。&lt;/p&gt;
&lt;h3 id=&quot;四、防坑提示&quot;&gt;&lt;a href=&quot;#四、防坑提示&quot; class=&quot;headerlink&quot; title=&quot;四、防坑提示&quot;&gt;&lt;/a&gt;四、防坑提示&lt;/h3&gt;&lt;p&gt;基于以上原因，所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/kenshinobiy/p/10797902.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.cnblogs.com/kenshinobiy/p/10797902.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前方有坑&quot;&gt;&lt;a href=&quot;#一、前方有坑&quot; class=&quot;headerlink&quot; title=&quot;一、前方有坑&quot;&gt;&lt;/a&gt;一、前方有坑&lt;/h3&gt;&lt;p&gt;php在使用加减乘除等运算符计算浮点数的时候，经常会出现意想不到的结果，特别是关于财务数据方面的计算，给不少
    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
      <category term="思考" scheme="http://isunman.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统安装Composer的两种方法</title>
    <link href="http://isunman.com/2021/04/26/two-ways-to-install-composer-on-a-linux-system/"/>
    <id>http://isunman.com/2021/04/26/two-ways-to-install-composer-on-a-linux-system/</id>
    <published>2021-04-25T16:12:00.000Z</published>
    <updated>2021-04-25T16:12:18.436Z</updated>
    
    <content type="html">&lt;p&gt;实际使用的系统：CentOS 6.5&lt;/p&gt;
&lt;h4 id=&quot;1、方法一-CURL&quot;&gt;&lt;a href=&quot;#1、方法一-CURL&quot; class=&quot;headerlink&quot; title=&quot;1、方法一 CURL&quot;&gt;&lt;/a&gt;1、方法一 CURL&lt;/h4&gt;&lt;p&gt;下载composer.phar文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sS https://getcomposer.org/installer | php
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将composer.phar移动到环境变量中并且更名为composer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv composer.phar  /usr/local/bin/composer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用国内镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;composer config -g repo.packagist composer https://packagist.phpcomposer.com
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2、方法二-直接下载composer&quot;&gt;&lt;a href=&quot;#2、方法二-直接下载composer&quot; class=&quot;headerlink&quot; title=&quot;2、方法二 直接下载composer&quot;&gt;&lt;/a&gt;2、方法二 直接下载composer&lt;/h4&gt;&lt;p&gt;下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://getcomposer.org/composer.phar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp composer.phar /usr/local/bin/composer
chmod u+x /usr/local/bin/composer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;composer –help&lt;/p&gt;
&lt;h4 id=&quot;3、安装的时候用root用户，使用的时候用非root用户&quot;&gt;&lt;a href=&quot;#3、安装的时候用root用户，使用的时候用非root用户&quot; class=&quot;headerlink&quot; title=&quot;3、安装的时候用root用户，使用的时候用非root用户&quot;&gt;&lt;/a&gt;3、安装的时候用root用户，使用的时候用非root用户&lt;/h4&gt;&lt;p&gt;否则，如果使用root运行会有提示：&lt;/p&gt;
&lt;p&gt;运行composer出现&lt;code&gt;do not run Composer as root/super user!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;第1步 创建非root的新用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@centos ~]# useradd newname
[root@centos ~]# passwd  newname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第2步 切换为新用户账户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@centos ~]# su newname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;切换到新用户后 , 即可执行 原来的操作 , 顺利完成 composer 指令。&lt;/p&gt;
&lt;p&gt;【注意】同时，需要使用root用户将 &lt;code&gt;/usr/local/bin/composer&lt;/code&gt; 设置为755，否则其他用户无法执行该命令。&lt;/p&gt;
&lt;p&gt;【本人亲测，使用上述方法2和步骤3成功安装了Composer 2.1-dev版。方法1未测试。】&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;实际使用的系统：CentOS 6.5&lt;/p&gt;
&lt;h4 id=&quot;1、方法一-CURL&quot;&gt;&lt;a href=&quot;#1、方法一-CURL&quot; class=&quot;headerlink&quot; title=&quot;1、方法一 CURL&quot;&gt;&lt;/a&gt;1、方法一 CURL&lt;/h4&gt;&lt;p&gt;下载composer.p
    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://isunman.com/tags/linux/"/>
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>服务器管理血的教训</title>
    <link href="http://isunman.com/2021/04/25/Server-management-blood-lessons/"/>
    <id>http://isunman.com/2021/04/25/Server-management-blood-lessons/</id>
    <published>2021-04-24T21:38:00.000Z</published>
    <updated>2021-04-24T21:58:54.272Z</updated>
    
    <content type="html">&lt;p&gt;服务器管理血的教训&lt;/p&gt;
&lt;p&gt;服务器管理，尤其是Linux服务器管理，必须注意以下几项原则，并做到。&lt;/p&gt;
&lt;h3 id=&quot;1、绝对不能随便使用rm-rf命令&quot;&gt;&lt;a href=&quot;#1、绝对不能随便使用rm-rf命令&quot; class=&quot;headerlink&quot; title=&quot;1、绝对不能随便使用rm -rf命令&quot;&gt;&lt;/a&gt;1、绝对不能随便使用&lt;code&gt;rm -rf&lt;/code&gt;命令&lt;/h3&gt;&lt;p&gt;因为会递归强制删除文件，几乎都不会可恢复。【影响响程度太深】&lt;/p&gt;
&lt;h5 id=&quot;挽救措施：&quot;&gt;&lt;a href=&quot;#挽救措施：&quot; class=&quot;headerlink&quot; title=&quot;挽救措施：&quot;&gt;&lt;/a&gt;挽救措施：&lt;/h5&gt;&lt;p&gt;1、马上停止数据继续写入，将系统挂起。使用一些恢复数据的方法进行磁盘数据数据恢复操作。一般不能全部恢复；而且还会影响线上的业务的停止。&lt;/p&gt;
&lt;p&gt;2、把快照的数据恢复到一个其他不是生产环境的阿里云服务器实例上，然后恢复到那个快照中的数据，再把误删除而需要的数据拷贝过来。原线上生产环境的业务不用停止。&lt;/p&gt;
&lt;h3 id=&quot;2、绝对不能使用-yum-update命令&quot;&gt;&lt;a href=&quot;#2、绝对不能使用-yum-update命令&quot; class=&quot;headerlink&quot; title=&quot;2、绝对不能使用 yum update命令&quot;&gt;&lt;/a&gt;2、绝对不能使用 &lt;code&gt;yum update&lt;/code&gt;命令&lt;/h3&gt;&lt;p&gt;因为会升级Linux 内核，而这个升级后的内核可能会引起各种问题。【影响范围太大】&lt;/p&gt;
&lt;h5 id=&quot;挽救措施：-1&quot;&gt;&lt;a href=&quot;#挽救措施：-1&quot; class=&quot;headerlink&quot; title=&quot;挽救措施：&quot;&gt;&lt;/a&gt;挽救措施：&lt;/h5&gt;&lt;p&gt;如果之前的系统内核还在，重启启动那个内核；&lt;br&gt;如果没问题的话，设置开机启动的内核为这个正常可用的内核。&lt;/p&gt;
&lt;h3 id=&quot;3、关键操作开始之前必须备份数据-快照&quot;&gt;&lt;a href=&quot;#3、关键操作开始之前必须备份数据-快照&quot; class=&quot;headerlink&quot; title=&quot;3、关键操作开始之前必须备份数据+快照&quot;&gt;&lt;/a&gt;3、关键操作开始之前必须备份数据+快照&lt;/h3&gt;&lt;p&gt;既不能因为精神不好产生错误的指令输入，或者粗心大意没有在意造成严重的后果；&lt;br&gt;又不能怕操作错误而什么都不敢做了。&lt;/p&gt;
&lt;p&gt;有一个宗旨【稳定第一】【宁愿冗余，也不得丢失数据】。&lt;/p&gt;
&lt;p&gt;不明确知道命令输入执行的后果的，就绝不执行。&lt;/p&gt;
&lt;p&gt;——————于2021年04月25日 凌晨5：35——必须记下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;服务器管理血的教训&lt;/p&gt;
&lt;p&gt;服务器管理，尤其是Linux服务器管理，必须注意以下几项原则，并做到。&lt;/p&gt;
&lt;h3 id=&quot;1、绝对不能随便使用rm-rf命令&quot;&gt;&lt;a href=&quot;#1、绝对不能随便使用rm-rf命令&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="服务器" scheme="http://isunman.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://isunman.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>DiscuzX3.1使用Composer安装第三方类库</title>
    <link href="http://isunman.com/2021/04/23/Discuz-X3.1-uses-Composer-to-install-third-party-libraries/"/>
    <id>http://isunman.com/2021/04/23/Discuz-X3.1-uses-Composer-to-install-third-party-libraries/</id>
    <published>2021-04-23T09:48:00.000Z</published>
    <updated>2021-04-23T10:01:10.112Z</updated>
    
    <content type="html">&lt;p&gt;Discuz X3.1 是一个成熟的基于PHP开发的社区系统（广义上来讲是一个建站系统），自从被企鹅收购后悄无声息的被遗弃了，伤感啊。如今要在Discuz上加什么功能，改bug什么的只能依靠自力更生了；好在有各种开源社区，开发好的功能、类库你可以无偿的直接拿来用。&lt;/p&gt;
&lt;p&gt;Composer 是一个PHP类库管理器（官网&lt;a href=&quot;http://docs.phpcomposer.com）。Composer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.phpcomposer.com）。Composer&lt;/a&gt; 优雅的解决了PHP项目中第三方类库的安装及依赖关系。很多成熟的项目（如 Laravel ）已经把Composer作为首选的安装方式；&lt;/p&gt;
&lt;p&gt;所以，在Discuz X3.1 上安装第三方类库使用Composer后，会很大提高生产力。&lt;/p&gt;
&lt;p&gt;下面我来说说如何在 Discuz X3.1中使用 Composer 安装并使用第三方类库 ；&lt;/p&gt;
&lt;h3 id=&quot;先说安装Composer到Discuz-X3-1框架下&quot;&gt;&lt;a href=&quot;#先说安装Composer到Discuz-X3-1框架下&quot; class=&quot;headerlink&quot; title=&quot;先说安装Composer到Discuz X3.1框架下&quot;&gt;&lt;/a&gt;先说安装Composer到Discuz X3.1框架下&lt;/h3&gt;&lt;h4 id=&quot;一-修改-class-core-php-source-class-class-core-php-如下&quot;&gt;&lt;a href=&quot;#一-修改-class-core-php-source-class-class-core-php-如下&quot; class=&quot;headerlink&quot; title=&quot;一. 修改 class_core.php (\source\class\class_core.php) 如下&quot;&gt;&lt;/a&gt;一. 修改 &lt;code&gt;class_core.php (\source\class\class_core.php)&lt;/code&gt; 如下&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$autoloadfile=DISCUZ_ROOT.&amp;apos;/vendor/autoload.php&amp;apos;;
if(!file_exists($autoloadfile)){  
    if(function_exists(&amp;apos;spl_autoload_register&amp;apos;)) {
        spl_autoload_register(array(&amp;apos;core&amp;apos;, &amp;apos;autoload&amp;apos;));
    } else {
           function __autoload($class) {
            return core::autoload($class);
        }
       }
}else{
    require_once  $autoloadfile;//如果存在Composer 加载器 ，则使用 ；
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;二-在-Discuz-目录下，新建一个-composer-json-内容如下：&quot;&gt;&lt;a href=&quot;#二-在-Discuz-目录下，新建一个-composer-json-内容如下：&quot; class=&quot;headerlink&quot; title=&quot;二. 在 Discuz 目录下，新建一个 composer.json 内容如下：&quot;&gt;&lt;/a&gt;二. 在 Discuz 目录下，新建一个 composer.json 内容如下：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;{

    &amp;quot;require&amp;quot;: {
         &amp;quot;guzzlehttp/guzzle&amp;quot;: &amp;quot;~6.0&amp;quot;
    },

    &amp;quot;autoload&amp;quot;:{
        &amp;quot;classmap&amp;quot;: [&amp;quot;source/class/&amp;quot;]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;三-终端上执行命令-composer-install&quot;&gt;&lt;a href=&quot;#三-终端上执行命令-composer-install&quot; class=&quot;headerlink&quot; title=&quot;三. 终端上执行命令 composer install&quot;&gt;&lt;/a&gt;三. 终端上执行命令 &lt;code&gt;composer install&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;看到类似这样的执行结果，表示已经安装成功了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 10 installs, 0 updates, 0 removals
  - Installing ralouphie/getallheaders (3.0.3): Loading from cache
  - Installing psr/http-message (1.0.1): Loading from cache
  - Installing guzzlehttp/psr7 (1.8.1): Loading from cache
  - Installing guzzlehttp/promises (1.4.1): Loading from cache
  - Installing symfony/polyfill-php72 (v1.19.0): Loading from cache
  - Installing symfony/polyfill-intl-normalizer (v1.19.0): Loading from cache
  - Installing paragonie/random_compat (v2.0.20): Loading from cache
  - Installing symfony/polyfill-php70 (v1.19.0): Loading from cache
  - Installing symfony/polyfill-intl-idn (v1.19.0): Loading from cache
  - Installing guzzlehttp/guzzle (6.5.5): Loading from cache
guzzlehttp/psr7 suggests installing laminas/laminas-httphandlerrunner (Emit PSR-   7 responses)
symfony/polyfill-intl-normalizer suggests installing ext-intl (For best performa   nce)
paragonie/random_compat suggests installing ext-libsodium (Provides a modern cry   pto API that can be used to generate random bytes.)
symfony/polyfill-intl-idn suggests installing ext-intl (For best performance)
guzzlehttp/guzzle suggests installing psr/log (Required for using the Log middle   ware)
Writing lock file
Generating autoload files
4 packages you are using are looking for funding.
Use the `composer fund` command to find out more!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，也可以查看项目根目录下的vendor下面的文件，核验新引入的类库是否下载更新成功。&lt;/p&gt;
&lt;p&gt;具体如何安装及使用 Composer 请参阅 &lt;a href=&quot;http://docs.phpcomposer.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.phpcomposer.com&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;再说在Discuz程序中如何使用-“composer安装”的第三方类库&quot;&gt;&lt;a href=&quot;#再说在Discuz程序中如何使用-“composer安装”的第三方类库&quot; class=&quot;headerlink&quot; title=&quot;再说在Discuz程序中如何使用 “composer安装”的第三方类库&quot;&gt;&lt;/a&gt;再说在Discuz程序中如何使用 “composer安装”的第三方类库&lt;/h3&gt;&lt;p&gt;通过Composer autoload 加载器会把这些第三方库自动加载进来，这些第三方类库程序中的类、方法(函数)等等 在Discuz 程序中你想怎么用都可以。&lt;/p&gt;
&lt;p&gt;例如，以使用guzzle为例。在任何一个Discuz X3.1框架下的PHP文件中，直接使用下面代码即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use GuzzleHttp\Client;

$client = new Client([
    // Base URI is used with relative requests
    &amp;apos;base_uri&amp;apos; =&amp;gt; &amp;apos;http://httpbin.org&amp;apos;,
    // You can set any number of default request options.
    &amp;apos;timeout&amp;apos;  =&amp;gt; 2.0,
]);

$response = $client-&amp;gt;get(&amp;apos;http://httpbin.org/get&amp;apos;);

$code = $response-&amp;gt;getStatusCode(); // 200
$reason = $response-&amp;gt;getReasonPhrase(); // OK

// Check if a header exists.
if ($response-&amp;gt;hasHeader(&amp;apos;Content-Length&amp;apos;)) {
    echo &amp;quot;It exists&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，Discuz X3.2 也适用上述方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Discuz X3.1 是一个成熟的基于PHP开发的社区系统（广义上来讲是一个建站系统），自从被企鹅收购后悄无声息的被遗弃了，伤感啊。如今要在Discuz上加什么功能，改bug什么的只能依靠自力更生了；好在有各种开源社区，开发好的功能、类库你可以无偿的直接拿来用。&lt;/p&gt;

    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Discuz" scheme="http://isunman.com/tags/discuz/"/>
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>DiscuzX二次开发之目录结构和运行逻辑</title>
    <link href="http://isunman.com/2021/04/23/DiscuzX-secondary-development-directory-structure-and-operational-logic/"/>
    <id>http://isunman.com/2021/04/23/DiscuzX-secondary-development-directory-structure-and-operational-logic/</id>
    <published>2021-04-22T19:15:00.000Z</published>
    <updated>2021-04-22T19:17:22.602Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-目录结构&quot;&gt;&lt;a href=&quot;#1-目录结构&quot; class=&quot;headerlink&quot; title=&quot;1.目录结构&quot;&gt;&lt;/a&gt;1.目录结构&lt;/h2&gt;&lt;p&gt;DISCUZ使用自己的框架，与现在主流的web框架不同，DISCUZ没有路由表，他的路由是由入口文件来实现的。&lt;/p&gt;
&lt;h3 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;api&quot;&gt;&lt;/a&gt;api&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;uc.php UCenter 通信文件&lt;/li&gt;
&lt;li&gt;/api/addons 应用中心&lt;/li&gt;
&lt;li&gt;/api/connect 通讯互联&lt;/li&gt;
&lt;li&gt;/api/google Google引擎结构处理&lt;/li&gt;
&lt;li&gt;/api/javascript 数据和广告的js调用&lt;/li&gt;
&lt;li&gt;/api/manyou manyou应用及搜索等相关服务&lt;/li&gt;
&lt;li&gt;/api/remote 远程更新&lt;/li&gt;
&lt;li&gt;/api/trade 支付宝、财付通等交易接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;archiver-论坛Archiver静态化目录&quot;&gt;&lt;a href=&quot;#archiver-论坛Archiver静态化目录&quot; class=&quot;headerlink&quot; title=&quot;archiver (论坛Archiver静态化目录)&quot;&gt;&lt;/a&gt;archiver (论坛Archiver静态化目录)&lt;/h3&gt;&lt;h3 id=&quot;config&quot;&gt;&lt;a href=&quot;#config&quot; class=&quot;headerlink&quot; title=&quot;config&quot;&gt;&lt;/a&gt;config&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;config_global.php 论坛核心参数配置文件&lt;/li&gt;
&lt;li&gt;config_ucenter.php UCenter核心参数配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;data-论坛数据缓存目录&quot;&gt;&lt;a href=&quot;#data-论坛数据缓存目录&quot; class=&quot;headerlink&quot; title=&quot;data (论坛数据缓存目录)&quot;&gt;&lt;/a&gt;data (论坛数据缓存目录)&lt;/h3&gt;&lt;h3 id=&quot;install-论坛安装目录-初始化运行时直接请求到此处将重新安装论坛&quot;&gt;&lt;a href=&quot;#install-论坛安装目录-初始化运行时直接请求到此处将重新安装论坛&quot; class=&quot;headerlink&quot; title=&quot;install (论坛安装目录(初始化运行时直接请求到此处将重新安装论坛))&quot;&gt;&lt;/a&gt;install (论坛安装目录(初始化运行时直接请求到此处将重新安装论坛))&lt;/h3&gt;&lt;h3 id=&quot;source-程序后端功能处理目录&quot;&gt;&lt;a href=&quot;#source-程序后端功能处理目录&quot; class=&quot;headerlink&quot; title=&quot;source (程序后端功能处理目录)&quot;&gt;&lt;/a&gt;source (程序后端功能处理目录)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;discuz_version.php 程序版本号文件&lt;/li&gt;
&lt;li&gt;/source/admincp 后台管理&lt;/li&gt;
&lt;li&gt;/source/archiver 论坛archiver静态化程序目录&lt;/li&gt;
&lt;li&gt;/source/class 核心类库&lt;/li&gt;
&lt;li&gt;/source/function discuzX自定义函数库&lt;/li&gt;
&lt;li&gt;/source/include 程序功能组件目录&lt;/li&gt;
&lt;li&gt;/source/language 程序语言包(kv结构)&lt;/li&gt;
&lt;li&gt;/source/module 程序功能模块程序包&lt;/li&gt;
&lt;li&gt;/source/plugins 插件扩展目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;static-程序资源目录-头像、图片、下载文件、js文件等等&quot;&gt;&lt;a href=&quot;#static-程序资源目录-头像、图片、下载文件、js文件等等&quot; class=&quot;headerlink&quot; title=&quot;static (程序资源目录(头像、图片、下载文件、js文件等等))&quot;&gt;&lt;/a&gt;static (程序资源目录(头像、图片、下载文件、js文件等等))&lt;/h3&gt;&lt;h3 id=&quot;template-前端模板目录&quot;&gt;&lt;a href=&quot;#template-前端模板目录&quot; class=&quot;headerlink&quot; title=&quot;template (前端模板目录)&quot;&gt;&lt;/a&gt;template (前端模板目录)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;/default/common 基础css文件、header、footer等公共引入文件&lt;/li&gt;
&lt;li&gt;/default/collage 大学计划页面&lt;/li&gt;
&lt;li&gt;/default/dige dige专区页面&lt;/li&gt;
&lt;li&gt;/default/forum 首页、帖子页面&lt;/li&gt;
&lt;li&gt;/default/member 会员页面&lt;/li&gt;
&lt;li&gt;/default/home 家园页面&lt;/li&gt;
&lt;li&gt;/default/group 群组页面&lt;/li&gt;
&lt;li&gt;/default/mobile 移动端页面&lt;/li&gt;
&lt;li&gt;/default/portal 文章页面&lt;/li&gt;
&lt;li&gt;/default/search 搜索页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;uc-client-UCenter客户端&quot;&gt;&lt;a href=&quot;#uc-client-UCenter客户端&quot; class=&quot;headerlink&quot; title=&quot;uc_client (UCenter客户端)&quot;&gt;&lt;/a&gt;uc_client (UCenter客户端)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;/uc_client/control UC业务处理操作类&lt;/li&gt;
&lt;li&gt;/uc_client/data 缓存文件目录&lt;/li&gt;
&lt;li&gt;/uc_client/lib 类库目录(包括数据库操作类,XML类,UCCODE类,邮件发送类)&lt;/li&gt;
&lt;li&gt;/uc_client/model UC业务模型类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;uc-server-UCenter服务端-后台ucenter功能实现目录&quot;&gt;&lt;a href=&quot;#uc-server-UCenter服务端-后台ucenter功能实现目录&quot; class=&quot;headerlink&quot; title=&quot;uc_server (UCenter服务端 后台ucenter功能实现目录)&quot;&gt;&lt;/a&gt;uc_server (UCenter服务端 后台ucenter功能实现目录)&lt;/h3&gt;&lt;h3 id=&quot;根目录文件&quot;&gt;&lt;a href=&quot;#根目录文件&quot; class=&quot;headerlink&quot; title=&quot;根目录文件&quot;&gt;&lt;/a&gt;根目录文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;admin.php 后台入口文件&lt;/li&gt;
&lt;li&gt;api.php API输出 入口文件&lt;/li&gt;
&lt;li&gt;collage.php 大学计划入口文件&lt;/li&gt;
&lt;li&gt;composer.json composer依赖版本记录文件&lt;/li&gt;
&lt;li&gt;composer.lock composer依赖版本控制文件&lt;/li&gt;
&lt;li&gt;connect.php 云平台接口文件&lt;/li&gt;
&lt;li&gt;dige.php dige专区入口文件&lt;/li&gt;
&lt;li&gt;forum.php 帖子信息入口文件&lt;/li&gt;
&lt;li&gt;group.php 群组入口文件&lt;/li&gt;
&lt;li&gt;home.php 家园入口文件&lt;/li&gt;
&lt;li&gt;index.php 首页&lt;/li&gt;
&lt;li&gt;member.php 用户入口文件（登录、注册、退出等）&lt;/li&gt;
&lt;li&gt;misc.php 程序杂项扩展入口&lt;/li&gt;
&lt;li&gt;plugin.php 插件入口文件&lt;/li&gt;
&lt;li&gt;portal.php 门户入口文件&lt;/li&gt;
&lt;li&gt;robots.txt 搜索引擎限制文件&lt;/li&gt;
&lt;li&gt;search.php 搜索频道入口文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-运行逻辑&quot;&gt;&lt;a href=&quot;#2-运行逻辑&quot; class=&quot;headerlink&quot; title=&quot;2. 运行逻辑&quot;&gt;&lt;/a&gt;2. 运行逻辑&lt;/h2&gt;&lt;p&gt;discuz的入口文件起到了路由的作用。一个标准的discuz请求如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost/home.php?mod=space&amp;amp;uid=1&amp;amp;do=profile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当在浏览器输入以上url时，首先执行的是跟目录下的 home.php 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

define(&amp;apos;APPTYPEID&amp;apos;, 1);
define(&amp;apos;CURSCRIPT&amp;apos;, &amp;apos;home&amp;apos;);

if(!empty($_GET[&amp;apos;mod&amp;apos;]) &amp;amp;&amp;amp; ($_GET[&amp;apos;mod&amp;apos;] == &amp;apos;misc&amp;apos; || $_GET[&amp;apos;mod&amp;apos;] == &amp;apos;invite&amp;apos;)) {
    define(&amp;apos;ALLOWGUEST&amp;apos;, 1);
}

require_once &amp;apos;./source/class/class_core.php&amp;apos;;  //引入核心类文件，作用为：自动引入类规则，错误和异常处理，单例创建discuz_application类实例，引入默认函数库function.core.php
require_once &amp;apos;./source/function/function_home.php&amp;apos;;  //引入discuzX函数库

$discuz = C::app();  //实例化discuz_application类
$cachelist = array(&amp;apos;magic&amp;apos;,&amp;apos;usergroups&amp;apos;, &amp;apos;diytemplatenamehome&amp;apos;,&amp;apos;forumlinks&amp;apos;,&amp;apos;identity&amp;apos;); //加身份组缓存
$discuz-&amp;gt;cachelist = $cachelist; //设置缓存列表
$discuz-&amp;gt;init();  //初始化应用:数据库、系统设置、用户、session、任务、等(discuz_appication类里面)
$space = array();

$mod = getgpc(&amp;apos;mod&amp;apos;); //接收$_GET[&amp;apos;mod&amp;apos;]数据
if(!in_array($mod, array(&amp;apos;space&amp;apos;, &amp;apos;spacecp&amp;apos;, &amp;apos;misc&amp;apos;, &amp;apos;magic&amp;apos;, &amp;apos;editor&amp;apos;, &amp;apos;invite&amp;apos;, &amp;apos;task&amp;apos;, &amp;apos;medal&amp;apos;, &amp;apos;rss&amp;apos;, &amp;apos;follow&amp;apos;))) {
    $mod = &amp;apos;space&amp;apos;;
    $_GET[&amp;apos;do&amp;apos;] = &amp;apos;home&amp;apos;;
}

if($mod == &amp;apos;space&amp;apos; &amp;amp;&amp;amp; ((empty($_GET[&amp;apos;do&amp;apos;]) || $_GET[&amp;apos;do&amp;apos;] == &amp;apos;index&amp;apos;) &amp;amp;&amp;amp; ($_G[&amp;apos;inajax&amp;apos;]))) {
    $_GET[&amp;apos;do&amp;apos;] = &amp;apos;profile&amp;apos;;
}
$curmod = !empty($_G[&amp;apos;setting&amp;apos;][&amp;apos;followstatus&amp;apos;]) &amp;amp;&amp;amp; (empty($_GET[&amp;apos;diy&amp;apos;]) &amp;amp;&amp;amp; empty($_GET[&amp;apos;do&amp;apos;]) &amp;amp;&amp;amp; $mod == &amp;apos;space&amp;apos; || $_GET[&amp;apos;do&amp;apos;] == &amp;apos;follow&amp;apos;) ? &amp;apos;follow&amp;apos; : $mod;
define(&amp;apos;CURMODULE&amp;apos;, $curmod);
runhooks($_GET[&amp;apos;do&amp;apos;] == &amp;apos;profile&amp;apos; &amp;amp;&amp;amp; $_G[&amp;apos;inajax&amp;apos;] ? &amp;apos;card&amp;apos; : $_GET[&amp;apos;do&amp;apos;]);
require_once libfile(&amp;apos;home/&amp;apos;.$mod, &amp;apos;module&amp;apos;);  //根据请求时传的mod参数经由上方判断确定加载对应文件

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注: libfile()函数在会将对应的模块字符串替换为模块的实际url。&lt;br&gt;&lt;code&gt;libfile(&amp;#39;home/&amp;#39;.$mod, &amp;#39;module&amp;#39;)&lt;/code&gt;的实际访问地址是 &lt;code&gt;/source/module/home/$mod.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入到&lt;code&gt;/source/module/home/home_space.php&lt;/code&gt; 文件中 根据请求参数 uid和do的值判断具体的执行过程，有些时候会直接引入响应的程序组件完成逻辑处理(这里引入了 &lt;code&gt;/include/space/space_profile.php&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;space_profile.php&lt;/code&gt;中判断运行之后输出到模板文件&lt;code&gt;/template/default/home/space_profile.htm&lt;/code&gt;中。&lt;br&gt;注：&lt;code&gt;template()&lt;/code&gt;函数在 核心函数库 &lt;code&gt;function_core.php&lt;/code&gt; 中 用于加载当前使用模板的模板文件 。根据传参此时加载了 &lt;code&gt;/template/default/home/space_profile.htm&lt;/code&gt; 文件&lt;/p&gt;
&lt;p&gt;在模板文件&lt;code&gt;space_profile.htm&lt;/code&gt;中 可以直接使用php文件中的数据变量进行赋值渲染输出到浏览器。&lt;br&gt;注：template模板语法不赘述 详见 &lt;a href=&quot;https://open.dismall.com/?ac=document&amp;amp;page=dev_template&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模板语法&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-目录结构&quot;&gt;&lt;a href=&quot;#1-目录结构&quot; class=&quot;headerlink&quot; title=&quot;1.目录结构&quot;&gt;&lt;/a&gt;1.目录结构&lt;/h2&gt;&lt;p&gt;DISCUZ使用自己的框架，与现在主流的web框架不同，DISCUZ没有路由表，他的路由是由入口文件来实现的
    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Discuz" scheme="http://isunman.com/tags/discuz/"/>
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP实现中文字符串的长度计算和截取无乱码</title>
    <link href="http://isunman.com/2021/04/12/PHP-to-achieve-the-length-of-Chinese-string-calculation-and-interception-without-garbled-code/"/>
    <id>http://isunman.com/2021/04/12/PHP-to-achieve-the-length-of-Chinese-string-calculation-and-interception-without-garbled-code/</id>
    <published>2021-04-12T07:42:00.000Z</published>
    <updated>2021-04-12T07:43:44.929Z</updated>
    
    <content type="html">&lt;p&gt;在我们学习PHP知识的过程中，PHP截取字符串应该是一个非常常见的字符串基础操作了，想必大家都比较熟悉这方面知识点。&lt;/p&gt;
&lt;p&gt;但是有些新手朋友们可能遇到过，当待截取的字符串出现中英文混合时，计算字符串的长度，会出现不准确和截取出现乱码的情况，其实这个也是非常容易解决的。&lt;/p&gt;
&lt;h3 id=&quot;首先，要了解关于中英文占多少字节的问题。&quot;&gt;&lt;a href=&quot;#首先，要了解关于中英文占多少字节的问题。&quot; class=&quot;headerlink&quot; title=&quot;首先，要了解关于中英文占多少字节的问题。&quot;&gt;&lt;/a&gt;首先，要了解关于中英文占多少字节的问题。&lt;/h3&gt;&lt;p&gt;ASCII码：一个中文汉字占两个字节的空间。&lt;/p&gt;
&lt;p&gt;UTF-8编码：一个中文（含繁体）等于三个字节。&lt;/p&gt;
&lt;p&gt;Unicode编码：一个中文（含繁体）等于两个字节。&lt;/p&gt;
&lt;h3 id=&quot;其次，如果是需要计算字符串的长度，需要明确是“字符”的长度还是“字节”的长度。&quot;&gt;&lt;a href=&quot;#其次，如果是需要计算字符串的长度，需要明确是“字符”的长度还是“字节”的长度。&quot; class=&quot;headerlink&quot; title=&quot;其次，如果是需要计算字符串的长度，需要明确是“字符”的长度还是“字节”的长度。&quot;&gt;&lt;/a&gt;其次，如果是需要计算字符串的长度，需要明确是“字符”的长度还是“字节”的长度。&lt;/h3&gt;&lt;p&gt;例如，是不是中英文数字符号等1个都算1个，还是按实际占用的字节计算。&lt;br&gt;这个需要看具体的使用场景，需要存储导数据时，需要按字节计算实际的长度，和数据库字段的长度匹配。需要前端显示时，可能需要按字符计算。&lt;/p&gt;
&lt;h3 id=&quot;第三，实际处理用到的两个函数mb-substr-和mb-strlen&quot;&gt;&lt;a href=&quot;#第三，实际处理用到的两个函数mb-substr-和mb-strlen&quot; class=&quot;headerlink&quot; title=&quot;第三，实际处理用到的两个函数mb_substr()和mb_strlen()&quot;&gt;&lt;/a&gt;第三，实际处理用到的两个函数&lt;code&gt;mb_substr()&lt;/code&gt;和&lt;code&gt;mb_strlen()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mb_substr($str,$start,$len,$encoding)&lt;/code&gt;，用于中文字符串的截取,在相应的编码页面输入相应的$encoding&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mb_strlen($str,$encodding)&lt;/code&gt;，用于获取中文字符串的长度，包含多字节的字符算成一个。&lt;/p&gt;
&lt;p&gt;GBK编码截取示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$str = &amp;apos;我是谁&amp;apos;;  //gbk编码的字符串
echo mb_substr($str, 0, 1, &amp;apos;gbk&amp;apos;); //输出 我
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;utf-8编码截取示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$str = &amp;apos;我abc是谁&amp;apos;;  //utf-8编码的字符串
echo mb_substr($str, 0, 2, &amp;apos;utf-8&amp;apos;); //输出 我a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中英混合也完全没有问题。&lt;/p&gt;
&lt;p&gt;【但是，一定要住编码需要明确指定，否则可能还是会出现乱码】&lt;/p&gt;
&lt;h3 id=&quot;第四，关于mb-strcut按字节来切分字符串，截取中文都不会产生半个字符的现象&quot;&gt;&lt;a href=&quot;#第四，关于mb-strcut按字节来切分字符串，截取中文都不会产生半个字符的现象&quot; class=&quot;headerlink&quot; title=&quot;第四，关于mb_strcut按字节来切分字符串，截取中文都不会产生半个字符的现象&quot;&gt;&lt;/a&gt;第四，关于&lt;code&gt;mb_strcut&lt;/code&gt;按字节来切分字符串，截取中文都不会产生半个字符的现象&lt;/h3&gt;&lt;p&gt;&lt;code&gt;substr&lt;/code&gt;、&lt;code&gt;mb_substr&lt;/code&gt;、&lt;code&gt;mb_strcut&lt;/code&gt;这三个函数都用来截取字符串，所不同的是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;substr&lt;/code&gt;是最简单的截取，无法适应中文；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mb_substr&lt;/code&gt;是按字来切分字符串，&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;mb_strcut&lt;/code&gt;是按字节来切分字符串，截取中文都不会产生半个字符的现象。&lt;/p&gt;
&lt;p&gt;这三个函数的前三个参数完全一致，即：&lt;/p&gt;
&lt;p&gt;第一个参数是操作对象&lt;/p&gt;
&lt;p&gt;第二个参数是截取的起始位置&lt;/p&gt;
&lt;p&gt;第三个参数是截取的数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mb_substr&lt;/code&gt;和&lt;code&gt;mb_strcut&lt;/code&gt;还有第四个参数：第四个参数可以根据不同的字符集进行设置。&lt;/p&gt;
&lt;h4 id=&quot;友情提示&quot;&gt;&lt;a href=&quot;#友情提示&quot; class=&quot;headerlink&quot; title=&quot;友情提示&quot;&gt;&lt;/a&gt;友情提示&lt;/h4&gt;&lt;p&gt;使用的时候要注意php文件的编码，和网页显示时的编码。&lt;/p&gt;
&lt;p&gt;使用这两个&lt;code&gt;mb_substr&lt;/code&gt; 和 &lt;code&gt;mb_strcut&lt;/code&gt;方法要事先知道字符串的编码，如果不知道编码，就需要判，mbstring库还提供了&lt;code&gt;mb_check_encoding&lt;/code&gt;来检验字符串编码，但还不完善。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mb_check_encoding($str,$encoding)&lt;/code&gt;;成功是返回true,失败时返回false;&lt;/p&gt;
&lt;p&gt;php中文字符串的截取  其中ord($str)&amp;gt;127(因为中文字符的acsii码的范围是128(即0x80-0xfe)-254)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在我们学习PHP知识的过程中，PHP截取字符串应该是一个非常常见的字符串基础操作了，想必大家都比较熟悉这方面知识点。&lt;/p&gt;
&lt;p&gt;但是有些新手朋友们可能遇到过，当待截取的字符串出现中英文混合时，计算字符串的长度，会出现不准确和截取出现乱码的情况，其实这个也是非常容易解决的
    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>苹果键盘的清洁</title>
    <link href="http://isunman.com/2021/02/18/apple-keyboard-cleaning/"/>
    <id>http://isunman.com/2021/02/18/apple-keyboard-cleaning/</id>
    <published>2021-02-18T14:28:00.000Z</published>
    <updated>2021-02-18T14:30:29.537Z</updated>
    
    <content type="html">&lt;p&gt;苹果键盘的清洁&lt;/p&gt;
&lt;p&gt;这里说的苹果键盘是：Mac 配件——妙控键盘 - 中文 (拼音)。带数字键和不带数字键的应该是类似的逻辑，本人实际使用的是不带数字键的。&lt;/p&gt;
&lt;p&gt;使用时间长了之后，键盘上面有一层脏东西，灰尘或者油污等。不带好清理，之前试过其他的方法，都不是太简单有效。今天突然试了一种新方法，简单直接有效。&lt;/p&gt;
&lt;p&gt;那就是，&lt;strong&gt;直接使用毛巾蘸清水，拧干水分之后，直接对键盘进行擦拭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面这个图片是按这个方法擦拭之后的键盘效果。&lt;br&gt;&lt;img src=&quot;http://fusihan.com/isunmanfiles/MagicKeyboard.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;苹果键盘的清洁&lt;/p&gt;
&lt;p&gt;这里说的苹果键盘是：Mac 配件——妙控键盘 - 中文 (拼音)。带数字键和不带数字键的应该是类似的逻辑，本人实际使用的是不带数字键的。&lt;/p&gt;
&lt;p&gt;使用时间长了之后，键盘上面有一层脏东西，灰尘或者油污等。不带好清理，之前试过其他的方法，都不
    
    </summary>
    
      <category term="Mac使用" scheme="http://isunman.com/categories/mac%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="工作" scheme="http://isunman.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="效率" scheme="http://isunman.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>PHP fsockopen 异步调用接口在nginx上偶尔实效的情况</title>
    <link href="http://isunman.com/2020/12/26/php-function-psockopen-asynchronous-call-interface-is-occasionally-useful-on-nginx/"/>
    <id>http://isunman.com/2020/12/26/php-function-psockopen-asynchronous-call-interface-is-occasionally-useful-on-nginx/</id>
    <published>2020-12-26T04:55:00.000Z</published>
    <updated>2020-12-26T04:56:25.717Z</updated>
    
    <content type="html">&lt;p&gt;在下面这段代码里面，调用后忽略执行结果直接返回，可用于php异步执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function fsock_asy_do($get){
    $fp = fsockopen(&amp;quot;ssl://www.xxx.com&amp;quot;, 443, $errno, $errstr, 30);
    if (!$fp) {
        echo &amp;quot;$errstr ($errno)&amp;lt;br /&amp;gt;\n&amp;quot;;
    } else {
        stream_set_blocking($fp,0);//开启非阻塞模式
        $out = &amp;quot;GET /&amp;quot;.$get.&amp;quot; HTTP/1.1\r\n&amp;quot;;
        $out .= &amp;quot;Host: www.xxxx.com\r\n&amp;quot;;
        $out .= &amp;quot;Connection: Close\r\n\r\n&amp;quot;;

        fwrite($fp, $out);
        /*忽略执行结果
        while (!feof($fp)) {
            echo fgets($fp, 128);
        }*/
        usleep(1000);
        fclose($fp);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在nginx服务器上有一个比较诡异的情况就是有时候无法调用异步的脚本。&lt;/p&gt;
&lt;p&gt;查阅相关资料后，是nginx 499 的问题。&lt;/p&gt;
&lt;p&gt;其中解决方案有以下，经过对每一个方案的验证最终得出结果：&lt;/p&gt;
&lt;h3 id=&quot;1、NGINX-499&quot;&gt;&lt;a href=&quot;#1、NGINX-499&quot; class=&quot;headerlink&quot; title=&quot;1、NGINX 499&quot;&gt;&lt;/a&gt;1、NGINX 499&lt;/h3&gt;&lt;p&gt;查看 NGINX access log，发现这样的请求会以 499（Client Closed Request）记录。确定问题是因为：客户端主动端口请求连接时，NGINX 不会将该请求代理给上游服务（FastCGI PHP 进程），这个时候 access log 中会以 499 记录这个请求。&lt;/p&gt;
&lt;p&gt;要解决这个问题需要将 NGINX FastCGI 忽略客户端中断配置打开：&lt;/p&gt;
&lt;p&gt;fastcgi_ignore_client_abort on;&lt;br&gt;这样无论客户端是否断开，都会将这个请求代理给上游，并且会记录上游服务处理后的返回状态。&lt;/p&gt;
&lt;h3 id=&quot;2、NGINX-线程原因&quot;&gt;&lt;a href=&quot;#2、NGINX-线程原因&quot; class=&quot;headerlink&quot; title=&quot;2、NGINX 线程原因&quot;&gt;&lt;/a&gt;2、NGINX 线程原因&lt;/h3&gt;&lt;p&gt;将nginx的worker_processes 由之前的auto修改为2（我的是单核服务器）&lt;/p&gt;
&lt;h3 id=&quot;3、NGINX-499&quot;&gt;&lt;a href=&quot;#3、NGINX-499&quot; class=&quot;headerlink&quot; title=&quot;3、NGINX 499&quot;&gt;&lt;/a&gt;3、NGINX 499&lt;/h3&gt;&lt;p&gt;nginx对499的定义是”client has closed connection”，并且在这些情况下会返回这个状态码：&lt;/p&gt;
&lt;p&gt;upstream 在收到读写事件处理之前时发现连接不可用。&lt;br&gt;server处理请求未结束，而client提前关闭了连接。&lt;br&gt;upstream出错，执行next_upstream时发现连接不可用。&lt;br&gt;一个不安全的做法是在fclose之前，让当前的进程先睡眠一段时间；我这里设置为10毫秒，这10毫秒的延迟对我完成整个请求的影响不大，同时我也认为nginx一定能在10毫米内把请求转到fastcgi去执行。这个时间间隔很难把握，不能保证php一定有执行到。&lt;/p&gt;
&lt;p&gt;这种方式并不是真正的异步，只是很取巧的强制关闭连接而不等待服务器端响应。所以在Laruence的那2篇文章中，有2个问题：&lt;/p&gt;
&lt;p&gt;①PHP使用fsock不能叫做异步，只是伪异步。&lt;/p&gt;
&lt;p&gt;②fwrite之后马上执行fclose，nginx会直接返回499&lt;/p&gt;
&lt;p&gt;由于我的代码上面usleep为1000，初步估计是时间不够导致没发出去就close了，所以调整为20000。并进行最后测试。&lt;br&gt;测试2天结果显示正常，的确是usleep数值过小的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在下面这段代码里面，调用后忽略执行结果直接返回，可用于php异步执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function fsock_asy_do($get){
    $fp = fsockopen(&amp;quot;ssl://www.xxx.com&amp;quot;
    
    </summary>
    
      <category term="技术日记" scheme="http://isunman.com/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="http://isunman.com/tags/php/"/>
    
      <category term="lnmp" scheme="http://isunman.com/tags/lnmp/"/>
    
  </entry>
  
  <entry>
    <title>win7下Apache突然启动失败</title>
    <link href="http://isunman.com/2020/12/18/win7-apache-suddenly-failed-to-start/"/>
    <id>http://isunman.com/2020/12/18/win7-apache-suddenly-failed-to-start/</id>
    <published>2020-12-18T04:45:00.000Z</published>
    <updated>2020-12-18T04:48:03.380Z</updated>
    
    <content type="html">&lt;p&gt;win7下Apache突然启动失败&lt;/p&gt;
&lt;p&gt;前段时间有一次重启了电脑（win7）之后，发现Apache服务并未随系统自动启动，结果在手动启动的时候也无法启动。&lt;/p&gt;
&lt;p&gt;报错为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows 不能在本地计算机启动apache2.4。有关更多信息，查阅系统事件日志。如果这是非Microsoft服务，请与服务厂商联系，并参考特定服务错误代码1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析后发现最大可能是80端口被占用，于是win+r 运行cmd&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;netstat -ano&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到80端口被PID4占用，于是打开任务管理器-进程-查看，选择列，勾选PID&lt;/p&gt;
&lt;p&gt;可以看到pid 4 的被NT kernel &amp;amp; System 占用&lt;/p&gt;
&lt;p&gt;该进程是Http.sys。它是http API的驱动组件，Http栈服务器。如果该端口被Http.sys占用，说明一些正在使用http.sys的应用程序在运行。这就是阻止Apache运行的原因，因为Http.sys占用着80端口。我们提供了一种应用程序的机制来帮助控制端口共享，但是我需要调查导致你遇到这种困难的是什么特殊应用程序。如果你能提供给我们“netsh http show servicestate”这条命令的输出结果，我就能找出是哪个应用程序在使用Http.sys。&lt;/p&gt;
&lt;p&gt;你可以按照下面步骤禁用http.sys：&lt;/p&gt;
&lt;p&gt;第一步： net stop http&lt;/p&gt;
&lt;p&gt;第二步：Sc config http start= disabled&lt;/p&gt;
&lt;p&gt;【正式操作步骤】&lt;/p&gt;
&lt;p&gt;于是运行&lt;code&gt;net stop http&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按“Y”确定&lt;/p&gt;
&lt;p&gt;再运行 &lt;code&gt;Sc config http start= disabled&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;好了，现在启动Apache，发现可以正常启动了。&lt;/p&gt;
&lt;p&gt;再查看一下netstat -ano&lt;/p&gt;
&lt;p&gt;发现pid 4占用了445端口（不再是80端口）。
　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;win7下Apache突然启动失败&lt;/p&gt;
&lt;p&gt;前段时间有一次重启了电脑（win7）之后，发现Apache服务并未随系统自动启动，结果在手动启动的时候也无法启动。&lt;/p&gt;
&lt;p&gt;报错为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows 不能在本地计算机启动apac
    
    </summary>
    
      <category term="Web构建" scheme="http://isunman.com/categories/web%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="wamp" scheme="http://isunman.com/tags/wamp/"/>
    
  </entry>
  
</feed>
